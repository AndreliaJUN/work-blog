[TOC]

# 2021.8.24

## 一、运行项目在Chrome中打开出现您的连接不是私密连接问题

这个问题大量出现在我访问公司网络，github之类的，头疼得很

您的连接不是私密连接
攻击者可能会试图从 x.x.x.x 窃取您的信息（例如：密码、通讯内容或信用卡信息）。了解详情
NET::ERR_CERT_INVALID

将您访问的部分网页的网址、有限的系统信息以及部分网页内容发送给 Google，以帮助我们提升 Chrome 的安全性。隐私权政策
x.x.x.x 通常会使用加密技术来保护您的信息。Google Chrome 此次尝试连接到 x.x.x.x 时，此网站发回了异常的错误凭据。这可能是因为有攻击者在试图冒充 x.x.x.x，或 Wi-Fi 登录屏幕中断了此次连接。请放心，您的信息仍然是安全的，因为 Google Chrome 尚未进行任何数据交换便停止了连接。

您目前无法访问 x.x.x.x，因为此网站发送了 Google Chrome 无法处理的杂乱凭据。网络错误和攻击通常是暂时的，因此，此网页稍后可能会恢复正常。

**解决：就是在当前页面用键盘输入 thisisunsafe ，不是在地址栏输入，就直接敲键盘就行了，页面即会自动刷新进入网页。**

原因：因为Chrome不信任这些自签名ssl证书，为了安全起见，直接禁止访问了，thisisunsafe 这个命令，说明你已经了解并确认这是个不安全的网站，你仍要访问就给你访问了。

## 二、props驼峰



# 2021.8.25

## 一、--save和--dev的作用与区别

![](img\image-20210825134337827.png)

![](img\image-20210825134507692.png)

--save-dev是指开发时依赖但是打包之后就不用的，下载的依赖在devDependencies里面显示

--save：将保存配置信息到pacjage.json。默认为dependencies节点中。

--dev：将保存配置信息devDependencies节点中。

因此：

--save：将保存配置信息到pacjage.json的dependencies节点中。

--save-dev：将保存配置信息到pacjage.json的devDependencies节点中。

dependencies：运行时的依赖，发布后，即生产环境下还需要用的模块

devDependencies：开发时的依赖。里面的模块是开发时用的，发布时用不到它。

## 二、script脚本作用以及终端命令

![](img\image-20210825134729878.png)

直接在终端写webpack使用的是全局的webpack打包

如果使用package.json里面的build:"webpack"命令打包优先使用本地的webpack进行打包（定义脚本的好处）

## 三、webpack loader加载顺序问题

![](img\image-20210825140719562.png)

## 四、作用域插槽的作用

简单来说就是 父组件不满意slot中数据展示方式但是还要用slot里的这个数据，父组件想换一种数据展现形式。

父组件替换插槽的标签，但是内容由子组件来提供。

子组件中包括一组数据，比如：pLanguages: ['JavaScript', 'Python', 'Swift', 'Go', 'C++']

需要在多个界面进行展示：

某些界面是以水平方向一一展示的，

某些界面是以列表形式展示的，

某些界面直接展示一个数组

这种情况就可以使用作用域插槽

# 2021.8.26

## 一、vur-router的学习

### 路由懒加载

```
export const routes = [{
    component: () => import('@/views/hello/index.vue'),
    name: 'hello',
    path: '/hello',
  },
  {
    component: () => import('@/views/svgIcons/index.vue'),
    name: 'svgIcons',
    path: '/svgIcons',
  }
  }]
  
```



只有用到这个组件时才去加载它。

# 2021.8.27

## 一、B端：新增一个菜单的流程是什么样子的

- （在sysconfig.js里面新增加一个菜单）该项目有这个步骤
- 在view中添加相应的文件夹以及在这个文件夹下新建一个页面

- 配置路由（懒加载）（在router文件夹下的index.js里进行配置)
- 将项目运行起来查看页面是否搭建成功
- 使用hui搭建dom页面，编写样式进行布局
- 在data里面绑定一些数据，v-model双向绑定的、需要从接口中获取的都定义一下
- 接下来就是在钩子函数以及定义的函数中去处理以及获取数据了处理数据的过程是根据接口文档来使用相应的api并且在传递数据的时候需注意对一些需要进行额外保护的数据使用util下的工具函数进行加密处理

\- 根据需求，先在根目录下的 `sysconfig.js` 里配置静态菜单，然后根据菜单列表，再在子系统里编写对应的路由地址，创建对应的目录文件即可

\- 然后再在部署的开发环境或者测试环境上，进行“操作员中心-系统菜单配置”进行生产环境的菜单配置及对应的按钮权限配置

## 二、 代码在开发的时候，你是怎么操作的 

## 三、构建的包怎么样在 see 平台进行部署的

## 四、axios的封装

## 五、promise的使用

## 六、scoped属性的作用

scoped 属性是一个布尔属性。

如果使用该属性，则样式仅仅应用到 style 元素的父元素及其子元素。

## 七、Vue中ref和$refs的作用

vue中的ref其实功能很强大，下面介绍一下它的主要功能以及使用方法。

### 功能一：本页面获取dom元素

```vue
<template>
  <div id="app">
    <div ref="testDom">11111</div>
    <button @click="getTest">获取test节点</button>
  </div>
</template>

<script>
export default {
  methods: {
    getTest() {
      console.log(this.$refs.testDom)
    }
  }
};
</script>
```

![](img\7047742-267ea7196ab3015d.webp)

### 功能二：拿到子组件中的data和去调用子组件中的方法

获取子组件数据

子组件：

```vue
<template>
  <div>
      {{ msg }}
  </div>
</template>

<script>
export default {
  data() {
    return {
      msg: "hello world"
    }
  }
}
</script>
```

父组件：

```vue
<template>
  <div id="app">
    <HelloWorld ref="hello"/>
    <button @click="getHello">获取helloworld组件中的值</button>
  </div>
</template>

<script>
import HelloWorld from "./components/HelloWorld.vue";

export default {
  components: {
    HelloWorld
  },
  data() {
    return {}
  },
  methods: {
    getHello() {
      console.log(this.$refs.hello.msg)
    }
  }
};
</script>
```

![](img\7047742-3d72465f00cc0c87.webp)

调用子组件方法

子组件：

```vue
<template>
  <div>
  </div>
</template>

<script>
export default {
  methods: {
    open() {
      console.log("调用到了")
    }
  }
}
</script>
```

父组件：

```vue
<template>
  <div id="app">
    <HelloWorld ref="hello"/>
    <button @click="getHello">获取helloworld组件中的值</button>
  </div>
</template>

<script>
import HelloWorld from "./components/HelloWorld.vue";

export default {
  components: {
    HelloWorld
  },
  data() {
    return {}
  },
  methods: {
    getHello() {
      this.$refs.hello.open();
    }
  }
};
</script>
```

![](img\7047742-e3bfdd2fc4c48d6d.webp)



# 2021.8.30

## 一、将前端资源部署到see平台上的全步骤

1. `"equity": "npm run child --child=equity_incentive --system_type=fronts --package=true --yes"`

   执行`npm run equity`将前端资源打成see包。

2. 进入项目的see平台

   ![](img\2021-08-30_164530.png)
   
   

点击应用服务->发布物管理->添加->选择发布物->选择打好的see压缩包->点击应用管理应用，选择刚刚上传上的资源进行配置（此时显示的应该是待配置）

![](img\2021-08-30_164827.png)

点击这个：

![](img\2021-08-30_165618.png)



进行配置：

![](img\2021-08-30_165859.png)



3. 配置完毕后就可以点击部署了然后进入网站在子系统中新建菜单

![](img\2021-08-30_171627.png)

![](img\2021-08-30_171810.png)

在弹出来的对话框进行配置

![](img\2021-08-30_172007.png)



![](img\2021-08-30_172241.png)

![](img\2021-08-30_172432.png)

这里的配置和sysconfig.js有一个对应关系

```json
children: [
        {
          url: null,
          kind_code: 'equity_incentive',
          app_code: 'equity_incentive',
          id: 'managerTest',
          title: '管理测试',
          parent_id: 'equity_incentive',
          icon: 'home',
          children: [
            {
              url: '/equity/fuShuXinXiGuanLi',
              kind_code: 'equity_incentive',
              app_code: 'equity_incentive',
              id: 'fuShuXinXiGuanLi',
              title: '附属信息管理测试',
              parent_id: 'managerTest',
              icon: 'home',
              is_keep_alive: true,
              children: null
            }
          ]
        }
 ]
```

![](img\2021-08-30_172725.png)

# 2021.8.31

## 一、Emmet语法

在首选项配置中将emmet.triggerExpansionOnTab设置为true值即可设置vscode可以使用emmet语法。

VSCode添加对Vue文件的Emmet语法支持：

1、在VSCode的插件内搜索Mithril Emmet，选择并安装

2、使用` Ctrl + Shift + P` 打开命令面板，输入Open Settings (JSON)，选择并进入设置的JSON格式配置页面。

3、并添加下面的键值内容（用于增加对.vue .wxml页面的扩展支持）

```
"emmet.includeLanguages": {
"wxml": "html",
"vue": "html"
}
```

### 1.后代:    >

 Child: > **缩写**：`div>ul>li`

### 2.兄弟：+

Sibling: + **缩写**：`div+p+bq`

### 3.上级：^

```html
 <!-- div+div>p>span+em^bq -->
    <div></div>
    <div>
      <p><span></span><em></em></p>
      <blockquote></blockquote>
    </div>
<!-- div+div>p>span+em+bq -->
    <div></div>
    <div>
      <p>
        <span></span><em></em>
        <blockquote></blockquote>
      </p>
    </div>
```

###  4.分组:（）

Grouping: ( )

```html
<!-- div>span+(p>a) -->
<div>
  <span></span>
  <p><a href=""></a></p>
</div>
<!-- (div>span)+(p>a) -->
<div><span></span></div>
<p><a href=""></a></p>
```

### 5.重复：*

### 6.编号：$

```html
<!-- ul>li.item$*5 -->
<ul>
  <li class="item1"></li>
  <li class="item2"></li>
  <li class="item3"></li>
  <li class="item4"></li>
  <li class="item5"></li>
</ul>
<!-- div.item$*3 -->
<div class="item1"></div>
<div class="item2"></div>
<div class="item3"></div>
<!-- h$[title=item$]{Header $}*3 -->
<h1 title="item1">Header 1</h1>
<h2 title="item2">Header 2</h2>
<h3 title="item3">Header 3</h3>
```

### 7.ID and 类名:   #  .

**缩写**：`#header`

```xml
    <div id="header"></div>
```

**缩写**：`.title`

```jsx
    <div class="title"></div>
```

**缩写**：`form#search.wide`

```jsx
    <form action="" id="search" class="wide"></form>
```

**缩写**：`p.class1.class2.class3`

```jsx
    <p class="class1 class2 class3"></p>
```

### 8.自定义属性:  [ ]

**缩写**：`p[title="Hello world"]`

```xml
    <p title="Hello world"></p>
```

**缩写**：`td[rowspan=2 colspan=3 title]`

```xml
    <td rowspan="2" colspan="3" title=""></td>
```

**缩写**：`[a='value1' b="value2"]`

```xml
    <div a="value1" b="value2"></div>
```

### 9.文本：{}

**缩写**：`a{Click me}`

```xml
     <a href="">Click me</a>
```

**缩写**：`p>{Click }+a{here}+{ to continue}`

```xml
    <p>Click <a href="">here</a> to continue</p>
  <!-- p{click}+a{here}+p{to continue} -->
  <p>click</p>
  <a href="">here</a>
  <p>to continue</p>
```



## 二、[webpack动态加载打包chunk命名](https://www.cnblogs.com/dahe1989/p/11543832.html)

昨天的部署出现了一个问题就是我把服务停了我写的菜单页面还能展示经检查才发现问题出在哪里。

我在编写路由的时候，直接复制的底下一个路由懒加载然后将路径改成了我建的文件名

```js
 // 练习页面 附属信息管理
  fuShuXinXiGuanLi: () => import(/* webpackChunkName: "equity_incentive/views/incentiveObjectManager/ancillaryInfoManager/ancillaryInfoManager"
  */'@equity/views/managerTest/fuShuXinXiGuanLi/fuShuXinXiGuanLi'),
  // 激励对象管理
  // 附属信息管理
  ancillaryInfoManager: () => import(/* webpackChunkName: "equity_incentive/views/incentiveObjectManager/ancillaryInfoManager/ancillaryInfoManager"
  */'@equity/views/incentiveObjectManager/ancillaryInfoManager/ancillaryInfoManager')
```

但是我没有改`/* webpackChunkName: "equity_incentive/views/incentiveObjectManager/ancillaryInfoManager/ancillaryInfoManager"`这个我以为是注释，但是不是，这个其实是webpack用来命名chunk的名称的，如果我不改那么我打包并且出来的路径和下面的是一样的名字（哈希值不一样所以还是两个文件）也就是说即使在浏览器url栏里我输入的是我自己定义的路径/fuShuXinXiGuanLi但是它去服务器找的依然是/ancillaryInfoManager

Webpack通过增加内联注释来告诉运行时，该有怎样的行为。通过向import中添加注释，我们可以执行诸如命名chunk或选择不同模式之类的操作。

## 三、SSH客户端MobaXterm

[参考博客](http://www.fobgavin.com/mobaxterm-instruction-1.html)

![](img\2021-08-31_144909.png)

## 四、typora快捷键

### 插入图片：直接拖动到指定位置即可或者ctrl+shift+i

### 侧边栏显示/隐藏切换：ctrl + shift + L

### 插入链接：[ctrl + k]()

### 代码：ctrl + shift + `

### 源码模式编辑切换：ctrl + /

### 下划线：<u>ctrl+u</u>

### 加粗：**ctrl+b**

### 倾斜：*ctrl+i*

### 跳转到文章开头：ctrl+home

### 跳转到文章结尾：ctrl+end

### 表格：ctrl+t

### 标题：ctrl+数字

## 五、如何将代码提交到gitlab（GitHub）指定分支下

1. 默认已有github账号和仓库项目，并且项目下有多个分支；

2. 默认git工具已正确安装；

3. 在本地将要上传的代码（or文件）的文件夹下空白处右键，右键会出现两个新选项，分别为Git Gui Here，Git Bash Here，这里我们选择Git Bash Here；

4. 初始化本地仓库
   \#如果之前有初始化 init 需要删除
   命令: `rm -rf .git`
   \#初始化本地仓库
   命令:` git init`

   初始化本地仓库后会在本地项目名后面出现(master)标志；

5. 连接远程git仓库，把github上面的仓库克隆到本地
   命令: `git clone https://github.com/XXXX/yyyy.git`（github仓库clone地址）

6. 这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你github上面的项目名,接着输入命令 cd XXX，进入clone到本地的文件夹;

7. 查看所有分支
   命令：`git branch -a`

8. 高亮色*master是我们初始化本地仓库出现的，剩下的三行红色是github仓库的所有主干和分支名字（一般master是主干名字，其他的是分支名字）;

   ![](img\2021-08-31_161257.png)

9. 切换到想要更新代码的分支目录下
   命令：`git checkout -t remotes/origin/dev(分支名)`

![](img\2021-08-31_161450.png)

如上图会看到由master切换到分支项目；

10. 剩一个自动生成的master，删掉
    命令`git branch -d master`

 ![](img\2021-08-31_161644.png)

11. 添加(修改）本地需要提交的代码
    ls一下可以看到github分支下的所有文件夹和文件，文件夹显示蓝色，文件显示白色；

12. 提交代码并添加说明
    `git add . `或者命令`git add newFile ` 把要上传的文件添加到仓库
    **注意**.代表提交全部更改到本地仓库，也可以将.改为指定的文件名。
    `git commit -m` “要上传文件的解释说明”

13. 上传代码到分支
    命令：`git push origin` 分支名

    上传成功，可以去github仓库分支下看到多了新上传的内容，并且对应有commit解释说明。

```shell
wangrj32319@HS-8RU2HICT MINGW64 /d/VsCode-demo/stock-i-w-d
$ git init
Initialized empty Git repository in D:/VsCode-demo/stock-i-w-d/.git/

wangrj32319@HS-8RU2HICT MINGW64 /d/VsCode-demo/stock-i-w-d (master)
$ git clone https://gitlab.hundsun.com/Winner_project/stock-incentive/stock-incentive-web.git
Cloning into 'stock-incentive-web'...
remote: Enumerating objects: 272, done.
remote: Counting objects: 100% (272/272), done.
remote: Compressing objects: 100% (157/157), done.
remote: Total 1330 (delta 139), reused 196 (delta 90)
Receiving objects: 100% (1330/1330), 11.69 MiB | 6.66 MiB/s, done.
Resolving deltas: 100% (598/598), done.

wangrj32319@HS-8RU2HICT MINGW64 /d/VsCode-demo/stock-i-w-d (master)
$ cd stock-incentive-web

wangrj32319@HS-8RU2HICT MINGW64 /d/VsCode-demo/stock-i-w-d/stock-incentive-web (master)
$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/dev
  remotes/origin/dev-bak
  remotes/origin/master

wangrj32319@HS-8RU2HICT MINGW64 /d/VsCode-demo/stock-i-w-d/stock-incentive-web (master)
$ git checkout -t remotes/origin/dev
Switched to a new branch 'dev'
Branch 'dev' set up to track remote branch 'dev' from 'origin'.

wangrj32319@HS-8RU2HICT MINGW64 /d/VsCode-demo/stock-i-w-d/stock-incentive-web (dev)
$ git branch -a
* dev
  master
  remotes/origin/HEAD -> origin/master
  remotes/origin/dev
  remotes/origin/dev-bak
  remotes/origin/master

wangrj32319@HS-8RU2HICT MINGW64 /d/VsCode-demo/stock-i-w-d/stock-incentive-web (dev)
$ ls
LICENSE    config/       gulpfile.js        package.json      src/
README.md  dllManifest/  index.ejs          release.json      static/
build/     documents/    package-lock.json  sh.exe.stackdump  sysconfig.js

wangrj32319@HS-8RU2HICT MINGW64 /d/VsCode-demo/stock-i-w-d/stock-incentive-web (dev)
$ git add README.md

wangrj32319@HS-8RU2HICT MINGW64 /d/VsCode-demo/stock-i-w-d/stock-incentive-web (dev)
$ git commit -m " "
Aborting commit due to empty commit message.

wangrj32319@HS-8RU2HICT MINGW64 /d/VsCode-demo/stock-i-w-d/stock-incentive-web (dev)
$ git commit -m "."
[dev 837def8] .
 1 file changed, 5 insertions(+), 5 deletions(-)

wangrj32319@HS-8RU2HICT MINGW64 /d/VsCode-demo/stock-i-w-d/stock-incentive-web (dev)
$ git push origin dev
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 8 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 308 bytes | 154.00 KiB/s, done.
Total 3 (delta 2), reused 0 (delta 0), pack-reused 0
remote:
remote: To create a merge request for dev, visit:
remote:   https://gitlab.hundsun.com/Winner_project/stock-incentive/stock-incentive-web/merge_requests/new?merge_request%5Bsource_branch%5D=dev
remote:
To https://gitlab.hundsun.com/Winner_project/stock-incentive/stock-incentive-web.git
   f8a619c..837def8  dev -> dev

wangrj32319@HS-8RU2HICT MINGW64 /d/VsCode-demo/stock-i-w-d/stock-incentive-web (dev)
$ git branch -d master
Deleted branch master (was d5ad333).

wangrj32319@HS-8RU2HICT MINGW64 /d/VsCode-demo/stock-i-w-d/stock-incentive-web (dev)
$ git branch -a
* dev
  remotes/origin/HEAD -> origin/master
  remotes/origin/dev
  remotes/origin/dev-bak
  remotes/origin/master

```

# 2021.9.1

## 一、flex布局

### 1.flex布局的优势

- 传统布局：兼容性好，布局繁琐，局限性在移动端不能很好布局 
- Flex布局：简单，操作方便，兼容性差 
- Pc采用传统布局，移动端或者不考虑兼容的pc可采用flex布局

### 2.flex布局原理

- Flex布局原理就是：给父盒子添加flex属性，来控制子盒子的位置排 列方式从而实现flex布局 
- 当我们为父盒子设为 flex 布局以后，子元素的 float、clear （指定段落的左侧或右侧不允许浮动的元素：clear:both）和 vertical-align（设置一个元素的垂直对齐方式） 属性将失效。 
- Flex布局又叫伸缩布局、弹性布局、伸缩盒布局、弹性盒布局、flex 布局

### 3.flex布局常用属性

#### 容器的属性

##### a.justify-content

**通过justify-content能够设置主轴子元素排列形式** 

- 值为flex-start 所有子元素在主轴头部显示 
-  值为flex-end 所有子元素在主轴尾部显示 
-  值为center 所有子元素**在主轴居中对齐** 
-  值为space-around 所有**子元素平分剩余空间** 
-  值为space-between 所有子元素**先两边贴边在平分剩余空间**

```html
<div class="parent">
     <p class="child"></p>
     <p class="child"></p>
     <p class="child"></p>
  </div>
```



```css
.parent{
       width: 100%;
       height: 300px;
       background-color: pink;
       display: flex;
       justify-content:space-around;
    }
    .child{
      width: 10%;
      height: 200px;
      background-color: #323232;
    }
```

![](img\2021-09-01_092805.png)

```
.parent{
       width: 100%;
       height: 300px;
       background-color: pink;
       display: flex;
       justify-content:space-between;
    }
    .child{
      width: 10%;
      height: 200px;
      background-color: #323232;
    }
```



![](img\2021-09-01_092950.png)

```
  .parent{
       width: 100%;
       height: 300px;
       background-color: pink;
       display: flex;
       justify-content:center;
    }
    .child{
      width: 10%;
      height: 200px;
      margin-right: 30px;
      background-color: #323232;
    }
```

![](img\2021-09-01_092222.png)

```
.parent{
       width: 100%;
       height: 300px;
       background-color: pink;
       display: flex;
       justify-content:flex-start;
    }
    .child{
      width: 10%;
      height: 200px;
      margin-right: 30px;
      background-color: #323232;
    }
```

![](img\2021-09-01_092304.png)



```css
   .parent{
       width: 100%;
       height: 300px;
       background-color: pink;
       display: flex;
       justify-content:flex-end;
    }
    .child{
      width: 10%;
      height: 200px;
      margin-right: 30px;
      background-color: #323232;
    }
```



![image-20210914161857331](img\image-20210914161857331.png)

##### b.flex-direction

**Flex布局中默认的主轴是row，x轴  主轴为水平方向，起点在左端。如果想改变主轴方向可通过设置flex-direction来改变** 

- flex-direction:column;将主轴改为y轴，纵轴  
- flex-direction:row; 将主轴改为x轴，横轴 
- flex-direction:row- reverse;主轴为x轴，并且翻转  主轴为水平方向，起点在右端。
- flex-direction:column- reverse;主轴为y轴，并且翻转

```
.parent{
      width: 800px;
      height: 1000px;
      margin: 0 auto;
       background-color: pink;
       display: flex;
       flex-direction: column;
       justify-content:space-between;
    }
    .child{
      margin: 0;
      width: 100px;
      height: 200px;
      background-color: #323232;
    }
```

<img src="img\image-20210906100703326.png" style="zoom:67%;" />



```
.parent{
      width: 800px;
      height: 1000px;
      margin: 0 auto;
       background-color: pink;
       display: flex;
       flex-direction: row;
       justify-content:space-between;
    }
    .child{
      margin: 0;
      width: 100px;
      height: 200px;
      color: blanchedalmond;
      background-color: #323232;
    }
```



![](img\image-20210906100621871.png)

```
    .parent{
      width: 800px;
      height: 1000px;
      margin: 0 auto;
       background-color: pink;
       display: flex;
       flex-direction: row-reverse;
       justify-content:space-between;
    }
    .child{
      margin: 0;
      width: 100px;
      height: 200px;
      color: blanchedalmond;
      background-color: #323232;
    }
```



![](img\image-20210906100922615.png)

```
    .parent{
      width: 800px;
      height: 1000px;
      margin: 0 auto;
       background-color: pink;
       display: flex;
       flex-direction: column-reverse;
       justify-content:space-between;
    }
    .child{
      margin: 0;
      width: 100px;
      height: 200px;
      color: blanchedalmond;
      background-color: #323232;
    }
```



<img src="img\image-20210906101009444.png" style="zoom: 67%;" />


![](img\image-20210906101650878.png)

##### c.flex-wrap

- 开启flex布局后默认为不换行 （如果子盒子比较多总宽度超过了父盒子那么在不换行的情况下所有的盒子将被压缩宽度减小放到父盒子里面）
- 如果想要换行效果设置flex-wrap：wrap `wrap`：换行，第一行在上方。
- `wrap-reverse`：换行，第一行在下方。

```
    .parent{
      width: 1000px;
      margin: 0 auto;
       background-color: pink;
       display: flex;
       flex-wrap: wrap;
    }
    .child{
      margin: 0;
      width: 200px;
      height: 200px;
      color: blanchedalmond;
      background-color: #323232;
    }
```



![image-20211129095215375](img\image-20211129095215375.png)

```
    .parent{
      width: 1000px;
       height: 400px;
       margin: 0 auto;
       background-color: pink;
       display: flex;
       flex-wrap: nowrap;
    }
    .child{
      margin: 0;
      width: 200px;
      height: 200px;
      color: blanchedalmond;
      background-color: #323232;
    }
```

![image-20211129095303945](img\image-20211129095303945.png)

```
    .parent{
      width: 1000px;
      margin: 0 auto;
       background-color: pink;
       display: flex;
       flex-wrap: wrap-reverse;
    }
    .child{
      margin: 0;
      width: 200px;
      height: 200px;
      color: blanchedalmond;
      background-color: #323232;
    }
```



![image-20211129095349663](img\image-20211129095349663.png)


##### d.align-items

**align-items属性定义项目在交叉轴上如何对齐（设置在侧轴上的子元素排列方式,子元素是单行时才能设置）。**

> ```css
> .box {
> align-items: flex-start （从上到下）| flex-end （从下到上） | center （挤在一起居中）| baseline | stretch（拉伸）;
> }
> ```

```
    .parent{
      width: 1000px;
      height: 400px;
      margin: 0 auto;
       background-color: pink;
       display: flex;
       /*当侧轴为y轴时在垂直方向上居中*/
       align-items:center
    }
    .child{
      margin: 0;
      width: 200px;
      height: 200px;
      margin-right: 10px;
      color: blanchedalmond;
      background-color: #323232;
    }
```

![](img\image-20210906105428079.png)

```
.parent{
      width: 1000px;
      height: 400px;
      margin: 0 auto;
       background-color: pink;
       display: flex;
       align-items:flex-end
    }
    .child{
      margin: 0;
      width: 200px;
      height: 200px;
      margin-right: 10px;
      color: blanchedalmond;
      background-color: #323232;
    }
```



![](img\image-20210906105726118.png)

```
 .parent{
      width: 1000px;
      height: 400px;
      margin: 0 auto;
       background-color: pink;
       display: flex;
       align-items:flex-start
    }
    .child{
      margin: 0;
      width: 200px;
      height: 200px;
      margin-right: 10px;
      color: blanchedalmond;
      background-color: #323232;
    }
```

![](img\image-20210906105825759.png)

```
   .parent{
       width: 100%;
       height: 500px;
       background-color: pink;
       display: flex;
       align-items: stretch;
    }
    .child{
      width: 10%;
      /* 子盒子不要设置高度 */
      /* height: 200px; */
      margin-right: 30px;
      background-color: #323232;
    }
```

![image-20210914162206131](img\image-20210914162206131.png)

既居中对齐又水平对齐

```css
.parent{
       width: 100%;
       height: 500px;
       background-color: pink;
       display: flex;
       align-items: center;
       justify-content: center;
    }
    .child{
      width: 10%;
      height: 200px;
      margin-right: 30px;
      background-color: #323232;
    }
```



![image-20210914162956848](img\image-20210914162956848.png)

##### e.align-content

align-content设置侧轴上的子元素的排列方式（只能用于子项出现换行的情况（多行），在单行下是没有效果的。）

- flex-start 默认值在侧轴的头部开始排列
- flex-end 在侧轴的尾部开始排列
- center在侧轴中间显示
- space-around子项在侧轴平分剩余空间
- space-between子项在侧轴先分布在两头，再平分剩余空间
- stretch设置子项元素高度平分父元素高度

***只设置换行不设置align-content的时候***

```html
  <style>
   .parent{
       width: 800px;
       height: 800px;
       background-color: pink;
       display: flex;
       flex-wrap: wrap;
    }
    .child{
      width: 150px;
      height: 150px;
      margin-right: 30px;
      background-color: #323232;
    }
  </style>

<body>
  <div class="parent">
    <p class="child">子盒子1</p>
    <p class="child">子盒子2</p>
    <p class="child">子盒子3</p>
    <p class="child">子盒子4</p>
    <p class="child">子盒子5</p>
    <p class="child">子盒子6</p>
    <p class="child">子盒子7</p>
    <p class="child">子盒子8</p>
  </div>
```

<img src="img\image-20210914164441832.png" alt="image-20210914164441832" style="zoom:50%;" />

**设置为center**

<img src="img\image-20210914164557711.png" alt="image-20210914164557711" style="zoom:50%;" />

**space-around**

<img src="img\image-20210914164728964.png" alt="image-20210914164728964" style="zoom:50%;" />

**space-between**

<img src="img\image-20210914164833447.png" alt="image-20210914164833447" style="zoom:50%;" />

**设置为flex-end**

<img src="img\image-20210914164931110.png" alt="image-20210914164931110" style="zoom:50%;" />

##### f.flex-flow

flex-flow属性是flex-direction和flex-wrap属性的复合属性

`flex-flow:row wrap`

#### 项目的属性

##### a.flex

flex设置子项目占的份数

**两边定宽中间自适应布局**

```html
  section {
    width: 60%;
    height: 150px;
    background-color: pink;
    margin: 0 auto;
    display: flex;
  }
  section div:nth-child(1){
    width: 100px;
    height: 150px;
    background-color: rgb(87, 67, 67);
  }
  section div:nth-child(2){
    flex: 1;
    background-color: rgb(148, 86, 86);
  }
  section div:nth-child(3){
    width: 100px;
    height: 150px;
    background-color: rgb(59, 57, 57);
  }

  <section>
    <div></div>
    <div></div>
    <div></div>
  </section>
```



![image-20210914181549421](img\image-20210914181549421.png)

**等分布局**

```css
  p {
    width: 60%;
    height: 150px;
    background-color: pink;
    margin: 100px auto;
    display: flex;
  }
  p span{
     flex: 1;
  }
  <p>
    <span>1</span><span>2</span><span>3</span>
  </p>
```

![image-20210914185729086](img\image-20210914185729086.png)

```css
  p {
    width: 60%;
    height: 150px;
    background-color: pink;
    margin: 100px auto;
    display: flex;
  }
  p span{
     flex: 1;
  }
  p span:nth-child(2){
    flex: 2;
    background-color: lightskyblue;
  }
```

![image-20210914185954911](img\image-20210914185954911.png)

##### b.align-self

控制某一个子盒子自己在侧轴的排列方式

```html
  section {
    width: 60%;
    height: 400px;
    background-color: pink;
    margin: 0 auto;
    display: flex;
  }
  section div{
    width: 100px;
    height: 100px;
    background-color: rgb(144, 225, 240);
    margin-right: 10px;
  }
  section div:nth-child(1){
  align-self: center;
  }
    <section>
    <div>1</div>
    <div>2</div>
    <div>3</div>
  </section>
```

<img src="img\image-20210914193211771.png" alt="image-20210914193211771" style="zoom:67%;" />

##### c.order

order属性定义子项的排列顺序（前后顺序）

数值越小，排列越靠前，默认为0

```
  section {
    width: 40%;
    height: 300px;
    background-color: pink;
    margin: 0 auto;
    display: flex;
  }
  section div{
    width: 100px;
    height: 100px;
    background-color: rgb(144, 225, 240);
    margin-right: 10px;
  }
  section div:nth-child(3){
  order: -1;
  }
```

![image-20210914193450010](img\image-20210914193450010.png)

## 

## 二、使用webpack dll插件对项目打包进行优化

scripts脚本中有这么一行`"predev": "npm run dll"`，好奇它是干什么的，这里做简单的介绍。

在用 Webpack 打包的时候，对于一些不经常更新的第三方库，比如 `react`，`lodash`，我们希望能和自己的代码分离开，Webpack 社区有两种方案

- CommonsChunkPlugin
- DLLPlugin

对于 `CommonsChunkPlugin`，webpack 每次打包实际还是需要去处理这些第三方库，只是打包完之后，能把第三方库和我们自己的代码分开。而
 `DLLPlugin` 则是能把第三方代码完全分离开，即每次只打包项目自身的代码。

### 使用方法

使用 `DLLPlugin`，需要额外新建一个配置文件。所以对于用这种方式打包的项目，一般会有下面两个配置文件

**在build下创建 webpack.dll.config.js**(我司项目是在build下)

```js
const path = require('path')
const webpack = require('webpack')
module.exports = {
  entry: {
    vendor: [
      'vue-router',
      'vuex',
      'vue/dist/vue.common.js',
      'vue/dist/vue.js',
      'vue-loader/lib/component-normalizer.js',
      'vue',
      'axios',
      'echarts'
    ]
  },
  output: {
    path: path.resolve('./dist'),
    filename: '[name].dll.js',
    library: '[name]_library'
  },
  plugins: [
    new webpack.DllPlugin({
      path: path.resolve('./dist', '[name]-manifest.json'),
      name: '[name]_library'
    }),
    new webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: false
      }
    })
  ]
}
```

这是把用到的第三方插件添加到 vendor 中。
**在 webpack.prod.conf.js 的 plugin 后面加入配置**

```
new webpack.DllReferencePlugin({
    manifest: require('../dist/vendor-manifest.json')
})
```

**根目录下的入口 index.html 加入引用**
`<script type="text/javascript" src="./vendor.dll.js"></script>`

**package.json的script里加入快捷命令**
`"build:dll": "webpack --config build/webpack.dll.config.js"`

要生成dll时运行`npm run build:dll`，即生成dist目录下两个文件 `vender-manifest.json` 与 `vender.dll.js`。

# 2021.9.2

##  一、公司文档

[新人入职指引（参考）](https://lylz1r.yuque.com/lylz1r/nmkzkg/gowux5)

[协作开发流程规范](https://lylz1r.yuque.com/lylz1r/nmkzkg/gtgfz3)

[前端H5包TS修改单填写说明](https://lylz1r.yuque.com/lylz1r/nmkzkg/mk68hc)

## 二、公司ts平台的使用（如何提交需求单）

![](img\2021-09-02_103317.png)

工作量： 按照实际的来  你实际开发这个需求用了多久之类的  预估一下
修改文件   不填（现在是git仓库，每次提交 集成平台会拉取最新代码进行打包）   如果是svn管理代码，那就需要填svn的提交的版本号
修改说明： 改了哪些东西
测试建议 ： 针对你修改的点 测试人员怎么能覆盖到

单元测试：

模块：

## 三、股权激励需求提交

2、自主行权统计表 的查询数据核对解决http://localhost:8091/#/equity/informationManager/exerciseManager

https://10.20.34.43:9443/bizframe/?redirect_uri=/g/hsxone.omc/v/reLogin?redirect_uri=/bizframe/#/informationManager/exerciseManager 已完成

![](img\image-20210902165540450.png)

![](img\image-20210902173542167.png)

![](img\image-20210902173611691.png)

修改了一些表头项的顺序

[自主行权统计表的修改](https://gitlab.hundsun.com/Winner_project/stock-incentive/stock-incentive-web/commit/d239efc1f449679b4b614117f0806345ddf91618)

3、资料服务：券商提供给上市公司相关资料 get 已完成

![](img\image-20210902165038315.png)

![](img\image-20210902175518567.png)

![image-20210902175546844](img\image-20210902175546844.png)

4、限售股持仓查询：结合限制性股票计划查询柜台限售股的持仓情况

![](img\image-20210902165701828.png)

5、激励效果分析：按计划分析计划进程、股份分布、卖出情况、收益分析 已完成

http://localhost:8091/#/equity/performanceAnalysis

https://10.20.34.43:9443/bizframe/?redirect_uri=/g/hsxone.omc/v/reLogin?redirect_uri=/bizframe/#/equity/performanceAnalysis

新增“绩效分析”功能板块：激励计划解锁/开始行权后，管理人员可通过“绩效分析”菜单查看绩效分析报告，包括解锁比例、激励收益、投资收益、持仓比例、负税比重等五个维度分析，供上市公司管理人员决策分析使用。

![](img\image-20210902180253376.png)



# 2021.9.3

## 一、Git日志提交规范

![](img\image-20210903134328452.png)

![](img\image-20210903134349743.png)

![](img\image-20210903134414105.png)

点击“审核不通过”，更新审核状态为“不通过” 

# 2021.9.6

## 一、package.json

```json
{
  "name": "test-project", // 项目名称
  "version": "1.0.0", // 版本号
  "description": "A Vue.js project", // 项目描述
  "main": "src/main.js", // 指定了加载的入口文件，require('moduleName')就会加载这个文件
  "private": true, // 私有标志，说明后防止误发到npm上
  "scripts": { // 脚本标识 ，用 run + 下列参数 可以执行对应node脚本
    "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
    "start": "npm run dev",
  },
  "keywords":["node.js","javascript"], // 和搜索引擎的keywords一样的作用
	"repository": { // 指明远程地址
		"type": "git",
		"url": "https://path/to/url"
	},
	"license":"MIT", // 指明该项目遵循的开源协议
  "bugs":{"url":"http://path/to/bug","email":"bug@example.com"}, // 有bug去哪找人修
	"contributors":[{"name":"李四","email":"lisi@example.com"}], // 协作者都有谁
  "dependencies": { // 依赖，项目运行所需要的环境，会打包到生产环境
    "vue": "^2.5.2"
  },
  "config" : { "port" : "8080" }, // 添加命令行的环境变量，在node环境中通过process.env.npm_package_config_port 获取
  "devDependencies": { // 同样是依赖，但是仅在开发环境下安装，生产环境不会安装
    "autoprefixer": "^7.1.2",
    "babel-core": "^6.22.1",
    "babel-eslint": "^8.2.1",
  },
  "engines": { //设置此软件包/应用程序要运行的 Node.js 或其他命令的版本。
    "node": ">= 6.0.0",
    "npm": ">= 3.0.0"
  },
  "browserslist": ["> 1%", "last 2 versions", "not ie <= 8"] 
  //用于告知要支持哪些浏览器（及其版本）。 Babel、Autoprefixer 和其他工具会用到它，以将所需的 polyfill 和 fallback 添加到目标浏览器。
}
```

## 二、Map

```js
equityPlan.vue
import {formatStatus, formatDate} from '@equity/filters/index.js'
render: (h, param) => {
            return h('span', {}, formatStatus(planTypeMap, param.row.planType))
          }

equity/filters/index.js
export function formatStatus (Map, status) {
  return Map[status]
}

constants.js
// 计划类型
export const planTypeMap = {
  0: '股票期权SO',
  1: '限制性股票RSA（第一类）',
  2: '限制性股票RSU（第二类）',
  3: '股票增值权SAR',
  4: '股票经济受益权SERs',
  5: '员工持股YGCG',
}
```

```js
test测试
// 计划类型
const planTypeMap = {
  0: '股票期权SO',
  1: '限制性股票RSA（第一类）',
  2: '限制性股票RSU（第二类）',
  3: '股票增值权SAR',
  4: '股票经济受益权SERs',
  5: '员工持股YGCG'
}

function formatStatus (Map, status) {
  return Map[status]
}

var result = formatStatus(planTypeMap, 0)

console.log(result)

```

```bash
node test.js
股票期权SO
```

## 三、object.keys()

### 语法

`Object.keys(obj)`

- 参数：要返回其枚举自身属性的对象
- 返回值：一个表示给定对象的所有可枚举属性的字符串数组

**处理对象，返回可枚举的属性数组**

```js
let person = {
 
    name : "zhangs",
    city : "xian",
    fav  : "sing"
}
 
Object.keys(person) // ["name","city","fav"]
```

**处理数组，就会返回数组的索引值**

```
let arr = [1,32,2,23,1]
Object.keys(arr) // ["0","1","2","3","4"]
```

**处理字符串，返回索引值数组**

```
let arr =  "strings"
Object.keys(str) // ["0","1","2","3","4","5","6"]
```

### 应用场景

```js
let person = {
 
    name : "zhangs",
    city : "xian",
    fav  : "sing"
}
 
Object.keys(person).map((key)=>{
 
    person[key]  //获取到对应的值，做一些操作
}) 
```



```js
equityPlanDetailDialog.vue
<h-select v-model="addForm.planType">
          <h-option v-for="item in planTypeList" :value="item.value" :key="item.value">{{ item.name }}</h-option>
</h-select>
planTypeList: selectOptionsHelper(planTypeMap)
import {selectOptionsHelper} from '@equity/utils/index.js'


@equity/utils/index.js
/**
 * select组件选项生成帮助类
 * @param {Object} optionMap 选项键值对
 */
export function selectOptionsHelper (optionMap) {
  return Object.keys(optionMap).map((key) => {
    return {
      value: key,
      name: optionMap[key]
    }
  })
}
```

```js
test测试
// 计划类型
const planTypeMap = {
  0: '股票期权SO',
  1: '限制性股票RSA（第一类）',
  2: '限制性股票RSU（第二类）',
  3: '股票增值权SAR',
  4: '股票经济受益权SERs',
  5: '员工持股YGCG'
}

/**
 * select组件选项生成帮助类
 * @param {Object} optionMap 选项键值对
 */
function selectOptionsHelper (optionMap) {
  return Object.keys(optionMap).map((key) => {
    return {
      value: key,
      name: optionMap[key]
    }
  })
}

var result = selectOptionsHelper(planTypeMap)

console.log(result)

```

```bash
 node test.js
[
  { value: '0', name: '股票期权SO' },
  { value: '1', name: '限制性股票RSA（第一类）' },
  { value: '2', name: '限制性股票RSU（第二类）' },
  { value: '3', name: '股票增值权SAR' },
  { value: '4', name: '股票经济受益权SERs' },
  { value: '5', name: '员工持股YGCG' }
]
```

# 2021.9.7

## 一、Vue  watch

### watch概述

一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。

```js
 data:{
     a:1,
     b:{
         c:1
     }
 },
 watch:{
     a(val, oldVal){//普通的watch监听
         console.log("a: "+val, oldVal);
     },
     b:{//深度监听，可监听到对象、数组的变化
         handler(val, oldVal){
             console.log("b.c: "+val.c, oldVal.c);
         },
         deep:true //true 深度监听
     }
 }
```



#### 简单的监听

```
<body>
<div id="app">
    <input type="text" v-model="num">
</div>
<script src="vue.js"></script>
<script>
    new Vue({
        el: '#app',
        data: {
            num: ''
        },
        watch: {
            num(newVal, oldVal) {
            // 监听 num 属性的数据变化
    		// 作用 : 只要 num 的值发生变化,这个方法就会被调用
    		// 第一个参数 : 新值
    		// 第二个参数 : 旧值,之前的值
                console.log('oldVal:',oldVal)
                console.log('newVal:',newVal)
            }
        }
    })
</script>
</body>

```


#### immediate（立即处理 进入页面就触发）

```html
<body>
<div id="app">
    <input type="text" v-model="num">
</div>
<script src="vue.js"></script>
<script>
    new Vue({
        el: '#app',
        data: {
            num: 1
        },
        watch: {
            num: {
            	// 数据发生变化就会调用这个函数  
                handler(newVal, oldVal) {
                    console.log('oldVal:', oldVal)
                    console.log('newVal:', newVal)
                },
                // 立即处理 进入页面就触发
                immediate: true
            }
        }
    })
</script>
</body>

```

#### deep（深度监听）

 对象和数组都是引用类型，引用类型变量存的是地址，地址没有变，所以不会触发watch。这时我们需要进行深度监听，就需要加上一个属性 deep，值为 true

```html
<body>
<div id="app">
    <input type="button" value="更改名字" @click="change">
</div>
<script src="vue.js"></script>
<script>
    new Vue({
        el: '#app',
        data: {
            food: {
                id: 1,
                name: '冰激凌'
            }
        },
        methods: {
            change() {
                this.food.name = '棒棒糖'
            }
        },
        watch: {
        	// 第一种方式：监听整个对象，每个属性值的变化都会执行handler
        	// 注意：属性值发生变化后，handler执行后获取的 newVal 值和 oldVal 值是一样的
            food: {
                // 每个属性值发生变化就会调用这个函数
                handler(newVal, oldVal) {
                    console.log('oldVal:', oldVal)
                    console.log('newVal:', newVal)
                },
                // 立即处理 进入页面就触发
                immediate: true,
                // 深度监听 属性的变化
                deep: true
            },
            // 第二种方式：监听对象的某个属性，被监听的属性值发生变化就会执行函数
            // 函数执行后，获取的 newVal 值和 oldVal 值不一样
            'food.name'(newVal, oldVal) {
                console.log('oldVal:', oldVal)   // 冰激凌
                console.log('newVal:', newVal)   // 棒棒糖
            }
        }
    })
</script>
</body>

```



![](img\image-20210907160035619.png)

### Watch和computed的区别

#### Watch

    watch用于观察和监听页面上的vue实例，当你需要在数据变化响应时，执行异步操作，或高性能消耗的操作，那么watch为最佳选择

#### computed

    可以关联多个实时计算的对象，当这些对象中的其中一个改变时都会触发这个属性
    具有缓存能力，所以只有当数据再次改变时才会重新渲染，否则就会直接拿取缓存中的数据。

computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计 算值变化才会返回内容。

watch 监听到值的变化就会执⾏回调，在回调中可以进⾏⼀些逻辑操作。

所以⼀般来说需要依赖别的属性来动态获得值的时候可以使⽤ computed ，对于监听到值 的变化需要做⼀些复杂业务逻辑的情况可以使⽤ watch 。

## 二、表单验证

在公司项目中使用的是hui框架form表单封装的async-async-validator

```js
<h-form-item label="总人数" prop="totalPerson" required :validRules="validRulesTotalPerson">
  data(){
   validRulesTotalPerson: [
        'intege1',
        {
          test: this.validTotalPerson,
          trigger: 'blur'
        }
      ]
  }  
  // 总人数校验
    validTotalPerson (rule, val, callback) {
      if (val > 10000) {
        callback(new Error('总人数不能超过1万'))
      } else {
        callback()
      }
    }
```

```js
  methods: {
    handleSubmit(name) {
      this.$refs[name].validate((valid) => {
        if (valid) {
          this.$hMessage.success("提交成功!");
        } else {
          this.$hMessage.error("表单验证失败!");
        }
      });
    },
    handleReset(name) {
      this.$refs[name].resetFields();
    }
  }
};
```



## 三、vue中的.sync修饰符以及$emit(update: )的用法

vue中我们经常会用v-bind(缩写为:)给子组件传入参数。
或者我们会给子组件传入一个函数，子组件通过调用传入的函数来改变父组件的状态。
例如：

```vue
//父组件给子组件传入一个函数
 <MyFooter :age="age" @setAge="(res)=> age = res">
 </MyFooter>
 //子组件通过调用这个函数来实现修改父组件的状态。
 mounted () {
      console.log(this.$emit('setAge',1234567));
 }

```

这时子组件触发了父组件的修改函数使父组件的age修改成了1234567

这种情况比较常见切写法比较复杂。于是我们引出今天的主角 .sync

这时我们可以直接这样写

```vue
//父组件将age传给子组件并使用.sync修饰符。
<MyFooter :age.sync="age">
</MyFooter>
//子组件触发事件
 mounted () {
    console.log(this.$emit('update:age',1234567));
 }

```

这里注意我们的事件名称被换成了update:age
update：是被固定的也就是vue为我们约定好的名称部分
age是我们要修改的状态的名称，是我们手动配置的，与传入的状态名字对应起来

这样就完成了，是不是感觉简单了很多。

注意事项：
这里我们必须在事件执行名称前加上update：的前缀才能正确触发事件。

# 2021.9.8

## 一、使用vuex保存用户权限并使用的过程

equityPlanDetail.vue

```js
 <h-button type="ghost" v-if="equityPlanManagerPermissions.check" @click="handleCheck(formItem)">审核通过</h-button>
     {{equityPlanManagerPermissions}}
 import { mapGetters } from 'vuex'
 
  computed: {
    ...mapGetters([
      'equityPlanManagerPermissions'//{ "update": true, "downloadTemplate": true, "equityPlanManager": true, "check": true, "exportDetail": true, "importDetail": true, "add": true, "delete": true }
    ])
  }


```

![image-20210908181257146](img\image-20210908181257146.png)

store/modules/equityIncentive.js

```js
import { getUserPermissions, getExchangeMarketDictItemList } from '@equity/api/bizSys/index.js'
import { permissionFormatterByModel } from '@equity/utils/index.js'

const equityIncentiveStore = {
  // namespaced: true,
  state: {
    exchangeMarket: [],
    userPermissions: {},
    count: 1
  },
  getters: {
    // @param {Object} allPermissions 所用用户功能权限
    // @param {String} modelPerfix 功能模块前缀
    equityPlanManagerPermissions (state) {
      return permissionFormatterByModel(state.userPermissions, 'equityPlanManager')
    }
   }
}

getUserPermissions().then(({data}) => {
  equityIncentiveStore.state.userPermissions = data[0]
}).catch((err) => {
  console.log(err)
})

export default equityIncentiveStore
```

打印一下userPermissions

![image-20210908181524979](img\image-20210908181524979.png)

src/biz/equity_incentive/static/json/getUserPermissions.json

```json
{
  "data": [
    {
      "equityPlanManager#equityPlanManager$/stockIncentive/incentivePlan/plans/tempPlan": "equityPlanManager#equityPlanManager$/stockIncentive/incentivePlan/plans/tempPlan",
      "equityPlanManager$update": "equityPlanManager$update",
      "equityPlanManager#equityPlanManager$/stockIncentive/incentivePlan/plans/delete": "equityPlanManager#equityPlanManager$/stockIncentive/incentivePlan/plans/delete",
      "equityPlanManager#equityPlanManager$/stockIncentive/incentivePlan/plans/update": "equityPlanManager#equityPlanManager$/stockIncentive/incentivePlan/plans/update"
     }
   ]
}
 
```

api/bizSys/index.js

```js
/**
 *  获取当前登录用户的所拥有权限
 */
export function getUserPermissions () {
  if (window.LOCAL_CONFIG.isToken) {
    // return fetch.get('/getUserPermissions').then(({data}) => {
    //   return data
    // })
    return fetch.get('/getUserPermissions').then(({data}) => {
      return {
        data: [
          data
        ]
      }
    })
  } else {
    return import('@equity/static/json/getUserPermissions.json')
  }
}
```



utils/index.js

```js
/**
 * 功能权限按照模块格式化工具方法
 * @param {Object} allPermissions 所用用户功能权限
 * @param {String} modelPerfix 功能模块前缀
 */
export function permissionFormatterByModel (allPermissions, modelPerfix) {
  const result = {}
  Object.keys(allPermissions).filter((key) => {
    return key.indexOf(`${modelPerfix}$`) === 0
  }).map((key) => {
    result[key.split('$')[1]] = true
  })
  return result
}
```

```
str.indexOf()

该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 searchvalue。开始检索的位置在字符串的 fromindex 处或字符串的开头（没有指定 fromindex 时）。如果找到一个 searchvalue，则返回 searchvalue 的第一次出现的位置。stringObject 中的字符位置是从 0 开始的。

split()
这个方法基于指定的分隔符将一个字符串分隔成多个字符串，并将结果放在一个数组中。
分隔符可以是字符串也可以是RegExp对象。
接收可选的第二个参数，用于指定数组大小，以便确保数组不会超过既定大小。
var colorText="red,blue,green,yellow";
var color1=colorText.split(",");//["red","blue","green","yellow"]
var colors2=colorText.split(",",2);//["red","blue"]
```

# 2021.9.9

## 一、工作中遇到的bug

```vue
<!-- prop	对应表单域 model 里的字段,也就是说prop必须得是model里的 -->
<h-form :model="addForm" >      
     <h-form-item label="存续起止日期" prop="inputSearchDate" required>
        <h-datePicker
          type="daterange"
          placeholder="选择日期"
          v-model="inputSearchDate"
          placement="bottom-end"
        ></h-datePicker>
      </h-form-item>
</h-form>
data(){
 addForm: {    
        startDate: '',
        endDate: '',
      },
 inputSearchDate: '',
}
这种情况下就会出现错误，required验证的prop不在model(addForm)里那么就一直是undefined，就会一直显示为空
解决办法：将prop里面的数据改成model里已有的比如startDate
```

![image-20210909191028626](img\image-20210909191028626.png)

# 2021.9.10

## 一、get请求过滤值为null的入参

```javascript
/**
 * get请求过滤值为null的入参
 * @param {Object} param 接口入参
 */
export function filterEmptyFromParamForGet (param) {
  const _param = {}
  for (let key in param) {
    param[key] !== '' && (_param[key] = param[key])
  }
  return _param
}
```

## 二、vue $t 是啥？

国际化 i18n 方案，$t 是 vue-i18n 提供的全局方法

[详情见此博客](https://blog.csdn.net/Dream_xun/article/details/82743762)

## 三、window.location.href

向指定的url提交数据

```js
/**
 * 下载模版
 * @param {Object} param
 */
export function downloadIncentivePlan (param) {
  window.location.href = window.EQUITY_CONFIG.API_HOME + '/incentivePlan/plans/tempPlan?' + Qs.stringify(param)
}
```

## 四、qs.parse()、qs.stringify()使用方法

qs是一个npm仓库所管理的包,可通过`npm install qs`命令进行安装.

1. qs.parse()将URL解析成对象的形式

   ```js
   const Qs = require('qs');
   let url = 'method=query_sql_dataset_data&projectId=85&appToken=7d22e38e-5717-11e7-907b-a6006ad3dba0';
   Qs.parse(url);
   console.log(Qs.parse(url));
   
   ```

   如上面代码所示,输出结果如下:

   ![这里写图片描述](img\9072ec19004e242eccba517b2fae8bc8.png)

2. qs.stringify()将对象 序列化成URL的形式，以&进行拼接

```js
const Qs = require('qs');
let obj= {
     method: "query_sql_dataset_data",
     projectId: "85",
     appToken: "7d22e38e-5717-11e7-907b-a6006ad3dba0",
     datasetId: " 12564701"
   };
Qs.stringify(obj);
console.log(Qs.stringify(obj));

```

如上面代码所示,输出结果如下:

![这里写图片描述](img\a0e7ae60fdb63224debd600847ecf398.png)

# 2021.9.13

## 一、Charles使用教程

## 二、Chrome开发技巧

### 1.快速切换文件

DevTools 被打开的时候，按 Ctrl+P（在 mac 是 cmd+p）, 就能快速搜寻和打开你项目的文件。

### 2.保存记录

勾选在 Console 标签下的保存记录选项，你可以使 DevTools 的 console 继续保存记录而不会在每个页面加载之后清除记录。当你想要研究在页面还没加载完之前出现的 bug 时，这会是一个很方便的方法。

![image-20210913094455347](img\image-20210913094455347.png)

### 3.颜色选择器

当在样式编辑中选择了一个颜色属性时，你可以点击颜色预览，就会弹出一个颜色选择器。当选择器开启时，如果你停留在页面，鼠标指针会变成一个放大镜，让你去选择像素精度的颜色。

![15 个必须知道的 chrome 开发工具技巧](img\201703011509586174.gif)

### 4.选择下一个匹配项

当在 Sources 标签下编辑文件时，按下 Ctrl + D (Cmd + D) ，当前选中的单词的下一个匹配也会被选中，有利于你同时对它们进行编辑。

![15 个必须知道的 chrome 开发工具技巧](img\201703011510222994.gif)

### 5.通过 workspaces 来编辑本地文件

Workspaces 是 Chrome DevTools 的一个强大功能，这使 DevTools 变成了一个真正的 IDE。Workspaces 会将 Sources 选项卡中的文件和本地项目中的文件进行匹配，所以你可以直接编辑和保存，而不必复制 / 粘贴外部改变的文件到编辑器。

为了配置 Workspaces，只需打开 Sources 选项，然后右击左边面板的任何一个地方，选择 **Add Folder To Worskpace，**或者只是把你的整个工程文件夹拖放入 Developer Tool。现在，无论在哪一个文件夹，被选中的文件夹，包括其子目录和所有文件都可以被编辑。为了让 Workspaces 更高效，你可以将页面中用到的文件映射到相应的文件夹，允许在线编辑和简单的保存。

## 三、如何打断点？

[参考博客](https://www.cnblogs.com/chengxuxing/p/7678042.html)

## 四、vue中什么时候使用template？

**template 元素是被当做一个不可见的包裹元素，主要用于分组的条件判断和列表渲染。**

在使用v-if 与 v-else-if 与 v-else v-for的时候,我们可以使用template,来代替div（这样可以减少无意义的div）

但在使用v-show时要注意,不能使用template,因为v-show是设置显示与隐藏，而template是没有实际东西的dom，所以v-show与template联合使用将失效。

# 2021.9.14

## 一、this.$nextTick()使用场景

公司的项目中在一个vue页面中使用了echarts，echarts是初始化是在mounted中使用this.$nextTick()方法，这里记录一下为啥要这么使用。

从使用结果可以知道，this.$nextTick()方法主要是用在随数据改变而改变的dom应用场景中，vue中数据和dom渲染由于是异步的，所以，要让dom结构随数据改变这样的操作都应该放进this.$nextTick()的回调函数中。created()中使用的方法时，dom还没有渲染，如果此时在该钩子函数中进行dom赋值数据（或者其它dom操作）时无异于徒劳，所以，此时this.$nextTick()就会被大量使用，而与created()对应的是mounted()的钩子函数则是在dom完全渲染后才开始渲染数据，所以在mounted()中操作dom基本不会存在渲染问题。

```vue
<div class="app">
  <div ref="msgDiv">{{msg}}</div>
  <div v-if="msg1">Message got outside $nextTick: {{msg1}}</div>
  <div v-if="msg2">Message got inside $nextTick: {{msg2}}</div>
  <div v-if="msg3">Message got outside $nextTick: {{msg3}}</div>
  <button @click="changeMsg">
    Change the Message
  </button>
</div>
 
 
new Vue({
  el: '.app',
  data: {
    msg: 'Hello Vue.',
    msg1: '',
    msg2: '',
    msg3: ''
  },
  methods: {
    changeMsg() {
      this.msg = "Hello world."
      this.msg1 = this.$refs.msgDiv.innerHTML
      this.$nextTick(() => {
        this.msg2 = this.$refs.msgDiv.innerHTML
      })
      this.msg3 = this.$refs.msgDiv.innerHTML
    }
  }
})
```

点击前：

![img](img\20190716160829257.png)

点击后：

![img](img\20190716160848674.png)

从上图可知，vue中的msg1和msg3显示的数据还是赋值之前的，msg2显示的数据则是赋值之后的。其根本原因是vue中的dom渲染是异步的。

## 二、window.addEventListener('resize',()=>{})

当浏览器调整大小时执行某函数



# 2021.9.16

## 一、vue $attrs的使用

$attrs的使用 vue
$attrs是在vue的2.40版本以上添加的。

![img](img\IMG_0002-1024x634.jpg)

现在我们来讨论一种情况，A组件与C组件怎么通信，我们有多少种解决方案？

1. 我们使用VueX来进行数据管理，但是如果项目中**多个组件共享状态比较少**，项目比较小，并且全局状态比较少,那使用VueX来实现该功能，并没有发挥出**VueX**的威力,有些大材小用。
2. 使用普通的父子组件传参prop和$emit，$on会很繁琐
3. 使用事件总线eventBus，使用不恰当的话，有可能会出现事件多次执行。

在很多开发情况下，我们只是想把A组件的信息传递给C组件，如果使用props 绑定来进行信息的传递，虽然能够实现，但是代码并不美观。

在vue2.4中，为了解决该需求，引入了**$attrs** 和**$listeners ，** 新增了**inheritAttrs** 选项。

如果给组件传递的数据，组件不使用props接收，那么这些数据将作为组件的HTML元素的特性，这些特性绑定在组件的HTML根元素上
inheritAttrs: false的含义是不希望本组件的根元素继承父组件的attribute，同时父组件传过来的属性（没有被子组件的props接收的属性），也不会显示在子组件的dom元素上，但是在组件里可以通过其$attrs可以获取到没有使用的注册属性, ``inheritAttrs: false`是不会影响 style 和 class 的绑定

以下是$attrs的使用示例（父组件的列表行数据传递给孙子组件展示）

1. 父组件（Father.vue），给子组件关联数据，子组件如果不用props接收，那么这些数据就作为普通的HTML特性应用在子组件的根元素上

```vue
<template>
  <div>
    <el-table :data='list'>
      <el-table-column
        prop="name"
        label="姓名"
      ></el-table-column>
      <el-table-column
        prop="study"
        label="学习科目"
      ></el-table-column>
      <el-table-column label="操作">
        <template slot-scope="scope">
          <el-button @click='transmitClick(scope.row)'>传递</el-button>
        </template>
      </el-table-column>
    </el-table>
    
    <!-- 儿子组件 -->
    <ChildView
      :is-show="isOpen"
      :row="row"
    >
    </ChildView>
  </div>
</template>

<script>
import ChildView from './Child.vue'
export default {
  components: { ChildView },
  data() {
    return {
      isOpen: false,
      row: {},
      list: [
        { name: '王丽', study: 'Java' },
        { name: '李克', study: 'Python' }
      ]
    }
  },
  methods: {
    // 传递事件
    transmitClick(row) {
      this.isOpen = true;
      this.row = row
    }
  }
}
</script>

```

2. 儿子组件（Child.vue），中间层，作为父组件和孙子组件的传递中介，在儿子组件中给孙子组件添加`v-bind="$attrs"`，这样孙子组件才能接收到数据

```vue
<template>
  <div class='child-view'>
    <p>儿子组件</p>
    <GrandChild v-bind="$attrs"></GrandChild>
  </div>
</template>

<script>
import GrandChild from './GrandChild.vue'
export default {
  // 继承所有父组件的内容
  inheritAttrs: true,
  components: { GrandChild },
  data() {
    return {
    }
  }
}
</script>

<style lang="stylus">
.child-view {
  margin: 20px
  border: 2px solid red
  padding: 20px
}
</style>

```

3. 孙子组件（GrandChild.vue），**在孙子组件中一定要使用props接收从父组件传递过来的数据**

```vue
<template>
  <div class='grand-child-view'>
    <p>孙子组件</p>
    <p>传给孙子组件的数据：{{row.name}} {{row.name !== undefined? '学习' : ''}} {{row.study}}</p>
  </div>
</template>

<script>
export default {
  // 不想继承所有父组件的内容,同时也不在组件根元素dom上显示属性
  inheritAttrs: false,
  // 在本组件中需要接收从父组件传递过来的数据，注意props里的参数名称不能改变，必须和父组件传递过来的是一样的
  props: {
    isShow: {
      type: Boolean,
      dedault: false
    },
    row: {
      type: Object,
      dedault: () => { }
    }
  }
}
</script>

<style lang="stylus">
.grand-child-view {
  border: 2px solid green
  padding: 20px
  margin: 20px
}
</style>

```

结果：

![在这里插入图片描述](img\20200421154342998.gif)

在上面提过，如果给子组件传递的数据，子组件不使用props接收，那么这些数据将作为子组件的特性，这些特性绑定在组件的HTML根元素上，在vue2.40版本之后，可以通过inheritAttrs = false 来控制这些特性是否显示在dom元素上 如：案例中父组件给子组件传递的row和isShow，子组件没有使用props接收，这个2个数据直接作为HTML的特殊属性。子组件使用inheritAttrs = true，那么特性显示在dom上，如果设置为false，那么特性不显示在dom上
![在这里插入图片描述](img\2020042116480571.png)

## 二、vue $listeners的使用

此时我们又想到了一个问题，**c组件的信息，怎么同步给a组件呢？** 

## 三、SVN常用命令说明

[参考博客](https://spike-leung.github.io/blog/others/svn-cheatsheet.html#%E7%BC%96%E8%BE%91)

## 四、JavaScript知识点补充

### 1.parseInt()

#### （1）基本用法

`parseInt`方法用于将字符串转为整数。

```
parseInt('123') // 123
```

如果字符串头部有空格，空格会被自动去除。

```
parseInt('   81') // 81
```

如果`parseInt`的参数不是字符串，则会先转为字符串再转换。

```
parseInt(1.23) // 1
// 等同于
parseInt('1.23') // 1
```

字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。

```
parseInt('8a') // 8
parseInt('12**') // 12
parseInt('12.34') // 12
parseInt('15e2') // 15
parseInt('15px') // 15
```

上面代码中，`parseInt`的参数都是字符串，结果只返回字符串头部可以转为数字的部分。

如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回`NaN`。

```
parseInt('abc') // NaN
parseInt('.3') // NaN
parseInt('') // NaN
parseInt('+') // NaN
parseInt('+1') // 1
```

所以，`parseInt`的返回值只有两种可能，要么是一个十进制整数，要么是`NaN`。

如果字符串以`0x`或`0X`开头，`parseInt`会将其按照十六进制数解析。

```
parseInt('0x10') // 16
```

如果字符串以`0`开头，将其按照10进制解析。

```
parseInt('011') // 11
```

对于那些会自动转为科学计数法的数字，`parseInt`会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。

```
parseInt(1000000000000000000000.5) // 1
// 等同于
parseInt('1e+21') // 1

parseInt(0.0000008) // 8
// 等同于
parseInt('8e-7') // 8
```

#### （2）进制转换

`parseInt`方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，`parseInt`的第二个参数为10，即默认是十进制转十进制。

```
parseInt('1000') // 1000
// 等同于
parseInt('1000', 10) // 1000
```

下面是转换指定进制的数的例子。

```
parseInt('1000', 2) // 8
parseInt('1000', 6) // 216
parseInt('1000', 8) // 512
```

上面代码中，二进制、六进制、八进制的`1000`，分别等于十进制的8、216和512。这意味着，可以用`parseInt`方法进行进制的转换。

如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回`NaN`。如果第二个参数是`0`、`undefined`和`null`，则直接忽略。

```
parseInt('10', 37) // NaN
parseInt('10', 1) // NaN
parseInt('10', 0) // 10
parseInt('10', null) // 10
parseInt('10', undefined) // 10
```

如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回`NaN`。

```
parseInt('1546', 2) // 1
parseInt('546', 2) // NaN
```

上面代码中，对于二进制来说，`1`是有意义的字符，`5`、`4`、`6`都是无意义的字符，所以第一行返回1，第二行返回`NaN`。

前面说过，如果`parseInt`的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。

```
parseInt(0x11, 36) // 43
parseInt(0x11, 2) // 1

// 等同于
parseInt(String(0x11), 36)
parseInt(String(0x11), 2)

// 等同于
parseInt('17', 36)
parseInt('17', 2)
```

上面代码中，十六进制的`0x11`会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串`17`，最后返回结果`43`和`1`。

这种处理方式，对于八进制的前缀0，尤其需要注意。

```
parseInt(011, 2) // NaN

// 等同于
parseInt(String(011), 2)

// 等同于
parseInt(String(9), 2)
```

上面代码中，第一行的`011`会被先转为字符串`9`，因为`9`不是二进制的有效字符，所以返回`NaN`。如果直接计算`parseInt('011', 2)`，`011`则是会被当作二进制处理，返回3。

JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个`0`。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。

### 2.表达式还是语句？

对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？

```
{ foo: 123 }
```

JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含`foo`属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签`foo`，指向表达式`123`。

为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。

```
{ console.log(123) } // 123
```

上面的语句是一个代码块，而且只有解释为代码块，才能执行。

如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。

```
({ foo: 123 }) // 正确
({ console.log(123) }) // 报错
```

这种差异在`eval`语句（作用是对字符串求值）中反映得最明显。

```
eval('{foo: 123}') // 123
eval('({foo: 123})') // {foo: 123}
```

上面代码中，如果没有圆括号，`eval`将其理解为一个代码块；加上圆括号以后，就理解成一个对象。

### 3.属性的读取

读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。

```
var obj = {
  p: 'Hello World'
};

obj.p // "Hello World"
obj['p'] // "Hello World"
```

上面代码分别采用点运算符和方括号运算符，读取属性`p`。

请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。

```
var foo = 'bar';

var obj = {
  foo: 1,
  bar: 2
};

obj.foo  // 1
obj[foo]  // 2
```

上面代码中，引用对象`obj`的`foo`属性时，如果使用点运算符，`foo`就是字符串；如果使用方括号运算符，但是不使用引号，那么`foo`就是一个变量，指向字符串`bar`。

方括号运算符内部还可以使用表达式。

```
obj['hello' + ' world']
obj[3 + 3]
```

数字键可以不加引号，因为会自动转成字符串。

```
var obj = {
  0.7: 'Hello World'
};

obj['0.7'] // "Hello World"
obj[0.7] // "Hello World"
```

上面代码中，对象`obj`的数字键`0.7`，加不加引号都可以，因为会被自动转为字符串。

注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。

```
var obj = {
  123: 'hello world'
};

obj.123 // 报错
obj[123] // "hello world"
```

上面代码的第一个表达式，对数值键名`123`使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。

### 4.属性的删除：delete 命令

`delete`命令用于删除对象的属性，删除成功后返回`true`。

```
var obj = { p: 1 };
Object.keys(obj) // ["p"]

delete obj.p // true
obj.p // undefined
Object.keys(obj) // []
```

上面代码中，`delete`命令删除对象`obj`的`p`属性。删除后，再读取`p`属性就会返回`undefined`，而且`Object.keys`方法的返回值也不再包括该属性。

注意，删除一个不存在的属性，`delete`不报错，而且返回`true`。

```
var obj = {};
delete obj.p // true
```

上面代码中，对象`obj`并没有`p`属性，但是`delete`命令照样返回`true`。因此，不能根据`delete`命令的结果，认定某个属性是存在的。

只有一种情况，`delete`命令会返回`false`，那就是该属性存在，且不得删除。

```
var obj = Object.defineProperty({}, 'p', {
  value: 123,
  configurable: false
});

obj.p // 123
delete obj.p // false
```

上面代码之中，对象`obj`的`p`属性是不能删除的，所以`delete`命令返回`false`。

另外，需要注意的是，`delete`命令只能删除对象本身的属性，无法删除继承的属性。

```
var obj = {};
delete obj.toString // true
obj.toString // function toString() { [native code] }
```

上面代码中，`toString`是对象`obj`继承的属性，虽然`delete`命令返回`true`，但该属性并没有被删除，依然存在。这个例子还说明，即使`delete`返回`true`，该属性依然可能读取到值。

### 5.属性是否存在：in 运算符

`in`运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回`true`，否则返回`false`。它的左边是一个字符串，表示属性名，右边是一个对象。

```
var obj = { p: 1 };
'p' in obj // true
'toString' in obj // true
```

`in`运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象`obj`本身并没有`toString`属性，但是`in`运算符会返回`true`，因为这个属性是继承的。

这时，可以使用对象的`hasOwnProperty`方法判断一下，是否为对象自身的属性。

```
var obj = {};
if ('toString' in obj) {
  console.log(obj.hasOwnProperty('toString')) // false
}
```

### 6.属性的遍历：for...in 循环

`for...in`循环用来遍历一个对象的全部属性。

```
var obj = {a: 1, b: 2, c: 3};

for (var i in obj) {
  console.log('键名：', i);
  console.log('键值：', obj[i]);
}
// 键名： a
// 键值： 1
// 键名： b
// 键值： 2
// 键名： c
// 键值： 3
```

`for...in`循环有两个使用注意点。

- 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
- 它不仅遍历对象自身的属性，还遍历继承的属性。

举例来说，对象都继承了`toString`属性，但是`for...in`循环不会遍历到这个属性。

```
var obj = {};

// toString 属性是存在的
obj.toString // toString() { [native code] }

for (var p in obj) {
  console.log(p);
} // 没有任何输出
```

上面代码中，对象`obj`继承了`toString`属性，该属性不会被`for...in`循环遍历到，因为它默认是“不可遍历”的。关于对象属性的可遍历性，参见《标准库》章节中 Object 一章的介绍。

如果继承的属性是可遍历的，那么就会被`for...in`循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用`for...in`的时候，应该结合使用`hasOwnProperty`方法，在循环内部判断一下，某个属性是否为对象自身的属性。

```
var person = { name: '老张' };

for (var key in person) {
  if (person.hasOwnProperty(key)) {
    console.log(key);
  }
}
// name
```

### 7.with 语句

`with`语句的格式如下：

```
with (对象) {
  语句;
}
```

它的作用是操作同一个对象的多个属性时，提供一些书写的方便。

```
// 例一
var obj = {
  p1: 1,
  p2: 2,
};
with (obj) {
  p1 = 4;
  p2 = 5;
}
// 等同于
obj.p1 = 4;
obj.p2 = 5;

// 例二
with (document.links[0]){
  console.log(href);
  console.log(title);
  console.log(style);
}
// 等同于
console.log(document.links[0].href);
console.log(document.links[0].title);
console.log(document.links[0].style);
```

注意，如果`with`区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。

```
var obj = {};
with (obj) {
  p1 = 4;
  p2 = 5;
}

obj.p1 // undefined
p1 // 4
```

上面代码中，对象`obj`并没有`p1`属性，对`p1`赋值等于创造了一个全局变量`p1`。正确的写法应该是，先定义对象`obj`的属性`p1`，然后在`with`区块内操作它。

这是因为`with`区块没有改变作用域，它的内部依然是当前作用域。这造成了`with`语句的一个很大的弊病，就是绑定对象不明确。

```
with (obj) {
  console.log(x);
}
```

单纯从上面的代码块，根本无法判断`x`到底是全局变量，还是对象`obj`的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用`with`语句，可以考虑用一个临时变量代替`with`。

```
with(obj1.obj2.obj3) {
  console.log(p1 + p2);
}

// 可以写成
var temp = obj1.obj2.obj3;
console.log(temp.p1 + temp.p2);
```

### 8.函数的重复声明

如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。

```
function f() {
  console.log(1);
}
f() // 2

function f() {
  console.log(2);
}
f() // 2
```

上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。

### 9.函数名的提升

JavaScript 引擎将函数名视同变量名，所以采用`function`命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。

```
f();

function f() {}
```

表面上，上面代码好像在声明之前就调用了函数`f`。但是实际上，由于“变量提升”，函数`f`被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。

```
f();
var f = function (){};
// TypeError: undefined is not a function
```

上面的代码等同于下面的形式。

```
var f;
f();
f = function () {};
```

上面代码第二行，调用`f`的时候，`f`只是被声明了，还没有被赋值，等于`undefined`，所以会报错。

注意，如果像下面例子那样，采用`function`命令和`var`赋值语句声明同一个函数，由于存在函数提升，最后会采用`var`赋值语句的定义。

```
var f = function () {
  console.log('1');
}

function f() {
  console.log('2');
}

f() // 1
```

上面例子中，表面上后面声明的函数`f`，应该覆盖前面的`var`赋值语句，但是由于存在函数提升，实际上正好反过来。

# 2021.9.17

# 一、vue created()中的执行函数报错剩下的还执行吗

# 2021.9.22

## 一、在data中初始化数据的注意事项

# 2021.9.23

## 一、Vue子组件调用父组件方法

Vue中子组件调用父组件的方法，这里有三种方法提供参考

第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法

父组件

```
<template>
  <div>
    <child></child>
  </div>
</template>
<script>
  import child from '~/components/dam/child';
  export default {
    components: {
      child
    },
    methods: {
      fatherMethod() {
        console.log('测试');
      }
    }
  };
</script>
```

子组件

```
<template>
  <div>
    <button @click="childMethod()">点击</button>
  </div>
</template>
<script>
  export default {
    methods: {
      childMethod() {
        this.$parent.fatherMethod();
      }
    }
  };
</script>
```

第二种方法是在子组件里用`$emit`向父组件触发一个事件，父组件监听这个事件就行了。

父组件

```
<template>
  <div>
    <child @fatherMethod="fatherMethod"></child>
  </div>
</template>
<script>
  import child from '~/components/dam/child';
  export default {
    components: {
      child
    },
    methods: {
      fatherMethod() {
        console.log('测试');
      }
    }
  };
</script>
```

子组件

```
<template>
  <div>
    <button @click="childMethod()">点击</button>
  </div>
</template>
<script>
  export default {
    methods: {
      childMethod() {
        this.$emit('fatherMethod');
      }
    }
  };
</script>
```

第三种是父组件把方法传入子组件中，在子组件里直接调用这个方法

父组件

```
<template>
  <div>
    <child :fatherMethod="fatherMethod"></child>
  </div>
</template>
<script>
  import child from '~/components/dam/child';
  export default {
    components: {
      child
    },
    methods: {
      fatherMethod() {
        console.log('测试');
      }
    }
  };
</script>
```

子组件

```
<template>
  <div>
    <button @click="childMethod()">点击</button>
  </div>
</template>
<script>
  export default {
    props: {
      fatherMethod: {
        type: Function,
        default: null
      }
    },
    methods: {
      childMethod() {
        if (this.fatherMethod) {
          this.fatherMethod();
        }
      }
    }
  };
</script>
```

## 二、项目中的批次号

```js
batchList

<h-select v-model="formItem.batchNum" placeholder="全部">
<h-option v-for="item in batchList">{{item.name}}</h-option>

//初始化batchNum是constant.js里面的
batchNum constant.js
// 批次
export const batchNum = {
  1: '1',
  2: '2',
  3: '3',
  4: '4',
  5: '5',
  6: '6',
  7: '7',
  8: '8'
}
/**
 * select组件选项生成帮助类
 * @param {Object} optionMap 选项键值对
 */
export function selectOptionsHelper(optionMap) {
  return Object.keys(optionMap).map((key) => {
    return {
      value: key,
      name: optionMap[key]
    }
  })
}
//初始化batchNumList使用工具函数获取选项键值对
batchNumList: selectOptionsHelper(batchNum), // 默认为value name12345678
[
    {
        "value": "1",
        "name": "1"
    },
    {
        "value": "2",
        "name": "2"
    },
    {
        "value": "3",
        "name": "3"
    },
    {
        "value": "4",
        "name": "4"
    },
    {
        "value": "5",
        "name": "5"
    },
    {
        "value": "6",
        "name": "6"
    },
    {
        "value": "7",
        "name": "7"
    },
    {
        "value": "8",
        "name": "8"
    }
]
  batchListMap: {}

//监听option中的batchList
batchList() {
  // 如果planIds长度发生了变化说明多选或少选了那么就要重新判断一下最大的次数
  if (this.formItem.planIds.length) {
    //去batchNumList中截取最大的
    return this.batchNumList.slice(0,
      // max(...[1,2,3...])现将数组展开然后选出最大值
      Math.max(...this.formItem.planIds.map((item) => {
        // map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。
        // 将planIds里面的每一项（选中的）都传入batchListMap中并返回由batchListMap[item]组成的数组（times数组）
        return this.batchListMap[item]
      })))
  } else {
    // 如果长度没有发生变化那就还是获取用监听batchNum得到的batchNumList
    return this.batchNumList
  }
}

this.batchListMap[item.id] = item.times

init () {
      // 获取计划名称下拉列表
      getIncentivePlanoOptions().then((res) => {
        this.planList = res.map((item) => {
          this.batchListMap[item.id] = item.times
          return {
            value: item.id,
            name: item.planName,
            type: item.planType,
            times: item.times,
            stockCode: item.stockCode
          }
        })
        this.formItem.planIds.push(this.planList[0].value)
        this.queryParamCatch = Object.assign({}, this.formItem)
        this.queryParamCatch.planIds = this.queryParamCatch.planIds.toString()
        this.fetchEquityPlanBatchData()
      }).catch((error) => {
        console.log('getIncentivePlanoOptions error: ', error)
      })
    },
```

## 三、为什么要进行浅复制深复制

  ```
    this.queryParamCatch = Object.assign({}, this.formItem)
  
    this.queryParamCatch.planIds = this.queryParamCatch.planIds.toString()
  ```

# 2021.9.24

## 一、position:relative

## 二、overflow:auto

## 三：HTML5 header元素

header元素是一种具有引导和导航作用的结构元素，通常用来放置整个页面或页面内的一个内容区块的标题，但也可以包含其他的内容，比如在header里面放置logo图片、搜索表单等等。

注意：一个页面内并没有限制header的出现次数，也就是说我们可以在同一页面内，不同的内容区块上分别加上一个header元素。

# 2021.9.28

1.要在mounted生命周期函数中实例化echarts对象。因为我们要确保dom元素已经挂载到页面中。

2.并不是mounted要等到created中所有的代码执行结束后才执行
执行顺序是：created中的同步任务–mounted中的同步任务–created中的异步任务–mounted中的异步任务



# 2021.9.30

[echarts自定义tooltip提示框内容](https://blog.csdn.net/dreamsup/article/details/56667330?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.no_search_link)

vue render函数

# 2021.10.8

## 一、echarts使用Ajax获取的数据显示在tooltip中

## 二、js如何将对象追加到数组中

## 三、for循环总是返回最后一个值

```javascript
 fetchTrendChartData () {
      esopNetWorthProductTrend({
        ...this.productCode
      }).then((res) => {

        let seriesData = []
        for (let i = 0; i < res.recentNetWorth.length; i++) {
          let resObj = {}//一定注意这里要写在for循环里面
          resObj.value = res.recentNetWorth[i]
          resObj.netWorthDate = res.netWorthDate[i]
          resObj.dailyGrowthRate = res.dailyGrowthRate[i]
          seriesData.push(resObj)
        }
        this.chartOption = {
          tooltip: {
            formatter: function (params) {
              return params[0].data.netWorthDate + '<br>单元净值： ' + params[0].data.value + '<br>日增长率： ' + params[0].data.dailyGrowthRate
            }
          },
          xAxis: {
            data: res.netWorthDate,
            axisLabel: {
              interval: res.xaxisStep
            }
          },
          yAxis: {
            interval: res.yaxisStep,
            max: res.yaxisMax,
            min: res.yaxisMin
          },
          series: {
            data: seriesData
          }
        }
        this.setChartOption(this.chartOption)
      }).catch((error) => {
        this.$hMessage.error(error)
      })
    },
  
```

```javascript
chartOption: {
        tooltip: {
          trigger: 'axis',
          backgroundColor: 'rgba(50,50,50,0.7)',
          borderColor: '#333',
          padding: 5,
          textStyle: { // 提示框浮层的文本样式。
            color: '#fff',
            fontStyle: 'normal',
            fontWeight: 'normal',
            fontFamily: 'sans-serif',
            fontSize: 14
          }
        },
        xAxis: {
          type: 'category',
          boundaryGap: false,
          data: [],
          axisLabel: {
            fontSize: '12',
            interval: 0
          }
        },
        yAxis: {
          type: 'value',
          axisLabel: {
            fontSize: '12'
          },
          interval: '',
          max: '',
          min: ''
        },
        series: {
          data: [],
          type: 'line',
          symbol: 'none',
          itemStyle: {
            normal: {
              areaStyle: {type: 'default'},
              color: new echarts.graphic.LinearGradient(
                0, 0, 0, 1,
                [
                  {offset: 0, color: '#e0f0ff'},
                  // {offset: 0.5, color: '#7BB7FC'},
                  {offset: 1, color: '#fff'}
                ]
              ),
              lineStyle: {
                color: '#298DFF'
              }
            }}
        },
        grid: {
          x: 50,
          y: 50,
          x2: 35,
          y2: 20,
          borderWidth: 1
        }
      },
```

# 2021.10.9

![img](img\Center)

[stash](https://blog.csdn.net/code_mzh/article/details/106999184?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link)

```
<template>
  <div class="page-content">
 <h-form :label-width="100" cols="4" class="query-form">
    <h-row>
      <h-form-item label="计划名称" prop="planIds">
        <h-select
          v-model="queryForm.planIds"
          @on-change="handlePlanChange"
        >
         <h-option v-for="item in planList" :value="item.value" :key="item.value">{{ item.name }}</h-option>
        </h-select>
      </h-form-item>
      <h-form-item label="计算模型" prop="">
       <h-input type="text" :placeholder="placeHolderTxt" disabled></h-input>
      </h-form-item>
            <h-form-item label="估算基准日">
       <h-date-picker type="date" placeholder="选择日期"></h-date-picker>
      </h-form-item>
      <h-form-item >
        <h-button type="primary" class="search-btn" @click="handleFormSearch(queryForm)">查询</h-button>
        <h-button type="ghost" @click="handleFormSearchReset()">重置</h-button>
      </h-form-item>
    </h-row>
  </h-form>
    <h-row class="title-box">
         <span class="value-cal">公允价值计算</span> <span class="explain">点击解锁列数字可编辑，编辑后需点击“价值计算”更新结果</span>  
     <h-button type="primary" class="value-cal-btn" @click="valueCalculateFun()">价值计算</h-button>
    </h-row>
    <h-edit-gird
      :columns="columns1"
      :data="calculateData1"
      size="large"
      @on-current-change="click1"
      :option="options1"
      :treeOption="treeOption"
    ></h-edit-gird>
    <p class="show-more">展开更多  <span><h-icon name="t-b-down"></h-icon></span></p>
    <h-table :columns="columns1" :data="calculateData2" :show-header="false" size="large"></h-table>
    <h-row class="title-box">
         <span class="value-cal">成本摊销估算 （万元）</span> <span class="explain">公允价值计算更新后，需点击摊销测算重新计算</span>
     <h-button type="primary" class="value-cal-btn" @click="estimateFunc()">摊销测算</h-button>
    </h-row>
    <h-table
      :multiLevel="multiLevel1" :data="foreCastData"
      width="100%"
    > </h-table>
  </div>
</template>
<script>
import iconCost from '@equity/assets/img/icon_cost.png'
import {IncentivePlanOptions} from '@equity/api/worthCalculate.js'
export default {
  data () {
    return {
      placeHolderTxt: '',
      currentPlanType: '',
      columns1: [
        {
          title: '序号',
          width: 150,
          key: 'index'
        },
        {
          title: '参数',
          key: 'param',
          width: 120
          // render: (h, p) => {
          //   return h(
          //     'div',
          //     [
          //       h(
          //         'img',
          //         {
          //           attrs: {
          //             src: iconCost
          //           },
          //           style: {

          //           }
          //         }
          //       )
          //     ]
          //   )
          // }
        },
        {
          title: '参数含义',
          key: 'paramMeaning',
          width: 250
        },
        {
          title: '估算参股取值',
          key: 'valueParticipation',
          width: 500
        },
        {
          title: '第1次解锁',
          key: 'firstUnlock',
          renderHeader: (h, param) => {
            return h(
              'div',
              [
                h(
                  'span',
                  {
                    style: {
                      display: 'inline-block',
                      marginRight: '150px'

                    }
                  },
                  '第1次解锁'
                ),
                h(
                  'span',
                  {
                    class: 'iconfont icon-edit'
                  }
                )
              ]
            )
          }
        },
        {
          title: '第1次解锁',
          key: 'firstUnlock',
          renderHeader: (h, param) => {
            return h(
              'div',
              [
                h(
                  'span',
                  {
                    style: {
                      display: 'inline-block',
                      marginRight: '150px'

                    }
                  },
                  '第2次解锁'
                ),
                h(
                  'span',
                  {
                    class: 'iconfont icon-edit'
                  }
                )
              ]
            )
          }
        },
        {
          title: '第1次解锁',
          key: 'firstUnlock',
          renderHeader: (h, param) => {
            return h(
              'div',
              [
                h(
                  'span',
                  {
                    style: {
                      display: 'inline-block',
                      marginRight: '150px'

                    }
                  },
                  '第3次解锁'
                ),
                h(
                  'span',
                  {
                    class: 'iconfont icon-edit'
                  }
                )
              ]
            )
          }
        }
      ],
      calculateData1: [{
        index: 1,
        param: 'Z',
        paramMeaning: '授予价格 （元/股）',
        valueParticipation: ''
      },
      {
        index: 2,
        param: 'S',
        paramMeaning: '标的股票当前价格 （元/股）',
        valueParticipation: '估算基准日公司股票收盘价'
      },
      {
        index: 3,
        param: 'X',
        paramMeaning: '期权执行价格 （元/股)',
        valueParticipation: '估算基准日公司股票的预期合理价格，为便于计算，此处假设第一期解锁日较授予日股价上涨10%，后一期解锁日较前一期解锁日股价上涨10%'
      },
      {
        index: 4,
        param: 'R',
        paramMeaning: '年化无风险利率 （%）',
        valueParticipation: '分别采用中国人民银行指定的金融机构1年期，2年期，3年期存款基准利率'
      },
      {
        index: 5,
        param: 'T',
        paramMeaning: '期权到期年限（年）',
        valueParticipation: '估算基准日至每期首个可解除限售日的期限'
      },
      {
        index: 6,
        param: 'σ',
        paramMeaning: '股价波动率（%）',
        valueParticipation: '分别采用上证综指'
      },
      {
        index: 7,
        param: 'δ',
        paramMeaning: '姑息收益率 （%）',
        valueParticipation: '估算基准日最新股息率'
      }
      ],
      calculateData2: [{
        index: 8,
        param: '',
        paramMeaning: 'S/X的自然对数',
        valueParticipation: ''
      },
      {
        index: 9,
        param: '',
        paramMeaning: '',
        valueParticipation: ''
      },
      {
        index: 10,
        param: 'd1',
        paramMeaning: ' ',
        valueParticipation: ''
      },
      {
        index: 11,
        param: 'd2',
        paramMeaning: '',
        valueParticipation: ''
      },
      {
        index: 12,
        param: '',
        paramMeaning: '标准正态分布中离差小于d1的概率',
        valueParticipation: ''
      },
      {
        index: 13,
        param: '',
        paramMeaning: '标准正态分布中离差小于d2的概率',
        valueParticipation: ''
      },
      {
        index: 14,
        param: '',
        paramMeaning: 'e的-σT次方',
        valueParticipation: ''
      },
      {
        index: 15,
        param: '',
        paramMeaning: 'e的-RT次方',
        valueParticipation: ''
      }
      ],
      queryForm: {
        planIds: ''
      },
      planList: [],
      foreCastListData: [],
      multiLevel1: [
        [
          {
            title: '摊销总金额',
            cols: 1,
            rows: 2,
            fixed: 'left'
          },
          {
            title: '解锁期',
            cols: 1,
            rows: 2,
            fixed: 'left'
          },
          {
            title: '摊销总月份',
            cols: 1,
            rows: 2,
            fixed: 'left'
          },
          {
            title: '2018年度',
            cols: 2,
            rows: 1,
            fixed: 'left'
          },
          {
            title: '2018年度',
            cols: 2,
            rows: 1,
            fixed: 'left'
          },
          {
            title: '2018年度',
            cols: 2,
            rows: 1,
            fixed: 'left'
          },
          {
            title: '2018年度',
            cols: 2,
            rows: 1,
            fixed: 'left'
          }
        ],
        [
          {
            title: '摊销月份',
            cols: 1,
            rows: 1,
            fixed: 'left'
          },
          {
            title: '摊销金额',
            cols: 1,
            rows: 1,
            fixed: 'left'
          },
          {
            title: '摊销月份',
            cols: 1,
            rows: 1,
            fixed: 'left'
          },
          {
            title: '摊销金额',
            cols: 1,
            rows: 1,
            fixed: 'left'
          },
          {
            title: '摊销月份',
            cols: 1,
            rows: 1,
            fixed: 'left'
          },
          {
            title: '摊销金额',
            cols: 1,
            rows: 1,
            fixed: 'left'
          },
          {
            title: '摊销月份',
            cols: 1,
            rows: 1,
            fixed: 'left'
          },
          {
            title: '摊销金额',
            cols: 1,
            rows: 1,
            fixed: 'left'
          }
        ]
      ]
    }
  },
  created () {
    this.getIncentivePlanOptions()
  },
  methods: {
    getIncentivePlanOptions () {
      IncentivePlanOptions().then((res) => {
        console.log(res)
        this.planList = res.map((list) => {
          return {
            value: list.id,
            name: list.planName,
            type: list.planType
          }
        })
        console.log(this.planList)
        this.queryForm.planIds = this.planList[0].value
        this.placeHolderTxt = this.planList[0].type === '0' ? 'B-S模型' : 'B-S模型（套期保值）'
      }).catch((error) => {
        this.$hMessage.error(error)
      })
    },
    handlePlanChange (currentId) {
      for (let i = 0; i < this.planList.length; i++) {
        if (this.planList[i].value === currentId) {
          this.currentPlanType = this.planList[i].type
          this.placeHolderTxt = this.currentPlanType === '0' ? 'B-S模型' : 'B-S模型（套期保值）'
          console.log(this.currentPlanType)
          console.log(this.placeHolderTxt)
        }
      }
    }
  }
}
</script>
<style lang="scss" scoped>
@import "./worthCalculate.scss";
</style>

```

# 2021.10.15

## win10快捷键

快捷键【Win + D】快速显示桌面

快捷键【Win + Tab】**快速切换任务窗口**

一般我们找文件，都要先打开【此电脑】，然后再打开磁盘。其实完全不必这样，按下快捷键【Win + E】就能立马打开资源管理器

win+L锁屏

alt+tab快速切换打开的页面

# 2021.10.20

## 一、git status出现提示Your branch is ahead of 'origin/master' by 1 commit。。。

当运行 `git status ,`git会将本地分支`dev`与它正在跟踪的远程分支进行比较（`origin/master`），因为`origin/master`没有被改变，它仍然是当前`dev`分支（和`origin/dev`）后面的1提交/更改，所以会出现提示。

我们想要做的是改变本地`dev`分支来跟踪远程`dev`分支。

解决方法（二选一）：

①、运行

```
git branch --set-upstream-to=origin/dev
```

②、在推送时附加`--set-upstream`到推送命令：

```
git push origin dev --set-upstream
```

# 2021.10.22

## 一、ES6之 扩展运算符...

### 1  含义

扩展运算符（ spread ）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。



```javascript
console.log(...[1, 2, 3])
// 1 2 3
console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5
[...document.querySelectorAll('div')]
// [<div>, <div>, <div>]
```


该运算符主要用于函数调用。

```javascript
function push(array, ...items) {
array.push(...items);
}
function add(x, y) {
return x + y;
}
var numbers = [4, 38];
add(...numbers) // 42
```

上面代码中，array.push(...items)和add(...numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。

扩展运算符与正常的函数参数可以结合使用，非常灵活。

```javascript
function f(v, w, x, y, z) { }
var args = [0, 1];
f(-1, ...args, 2, ...[3]);
```

### 2  替代数组的 apply 方法

由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。

```javascript
// ES5 的写法
function f(x, y, z) {
// ...
}
var args = [0, 1, 2];
f.apply(null, args);
// ES6 的写法
function f(x, y, z) {
// ...
}
var args = [0, 1, 2];
f(...args);
```


下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。

```javascript
// ES5 的写法
Math.max.apply(null, [14, 3, 77])
// ES6 的写法
Math.max(...[14, 3, 77])
//  等同于
Math.max(14, 3, 77);
```

上面代码表示，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。

另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。

```javascript
// ES5 的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);
// ES6 的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1.push(...arr2);
```

上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。
下面是另外一个例子。

```javascript
// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);
```

### 3  扩展运算符的应用

#### （ 1 ）合并数组

扩展运算符提供了数组合并的新写法。

```javascript
// ES5
[1, 2].concat(more)
// ES6
[1, 2, ...more]
var arr1 = ['a', 'b'];
var arr2 = ['c'];
var arr3 = ['d', 'e'];
// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]
// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ 'a', 'b', 'c', 'd', 'e' ]
```

#### （ 2 ）与解构赋值结合

扩展运算符可以与解构赋值结合起来，用于生成数组。



```javascript
// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
下面是另外一些例子。
const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest // [2, 3, 4, 5]
const [first, ...rest] = [];
first // undefined
rest // []:
const [first, ...rest] = ["foo"];
first // "foo"
rest // []
```

如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。

```javascript
const [...butLast, last] = [1, 2, 3, 4, 5];
//  报错
const [first, ...middle, last] = [1, 2, 3, 4, 5];
//  报错
```

#### （ 3 ）函数的返回值

JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。

```javascript
var dateFields = readDateFields(database);
var d = new Date(...dateFields);
```

上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。

#### （ 4 ）字符串

扩展运算符还可以将字符串转为真正的数组。

```javascript
[...'hello']
// [ "h", "e", "l", "l", "o" ]
```

上面的写法，有一个重要的好处，那就是能够正确识别 32 位的 Unicode 字符。

```javascript
'x\uD83D\uDE80y'.length // 4

[...'x\uD83D\uDE80y'].length // 3
```

上面代码的第一种写法， JavaScript 会将 32 位 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。**因此，正确返回字符串长度的函数，可以像下面这样写。**

```javascript
function length(str) {
return [...str].length;
}
length('x\uD83D\uDE80y') // 3
```

**凡是涉及到操作 32 位 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。**

```javascript
let str = 'x\uD83D\uDE80y';
str.split('').reverse().join('')
// 'y\uDE80\uD83Dx'
[...str].reverse().join('')
// 'y\uD83D\uDE80x'
```

上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。

#### （ 5 ）实现了 Iterator 接口的对象

任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组。

```javascript
var nodeList = document.querySelectorAll('div');
var array = [...nodeList];
```

上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 接口。

对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。

```javascript
let arrayLike = {
'0': 'a',
'1': 'b',
'2': 'c',
length: 3
};
// TypeError: Cannot spread non-iterable object.
let arr = [...arrayLike];
```

上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。

#### （ 6 ） Map 和 Set 结构， Generator 函数

扩展运算符内部调用的是数据结构的 Iterator 接口，**因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。**

```javascript
let map = new Map([
[1, 'one'],
[2, 'two'],
[3, 'three'],
]);
let arr = [...map.keys()]; // [1, 2, 3]
```

Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。

```javascript
var go = function*(){
yield 1;
yield 2;
yield 3;
};
[...go()] // [1, 2, 3]
```

上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。
如果对没有iterator接口的对象，使用扩展运算符，将会报错。

```javascript
var obj = {a: 1, b: 2};
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
```

#### （7）复制数组

数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。

```javascript
const a1 = [1, 2];
const a2 = a1;

a2[0] = 2;
a1 // [2, 2]
```

上面代码中，`a2`并不是`a1`的克隆，而是指向同一份数据的另一个指针。修改`a2`，会直接导致`a1`的变化。

ES5 只能用变通方法来复制数组。

```javascript
const a1 = [1, 2];
const a2 = a1.concat();

a2[0] = 2;
a1 // [1, 2]
```

上面代码中，`a1`会返回原数组的克隆，再修改`a2`就不会对`a1`产生影响。

扩展运算符提供了复制数组的简便写法。

```javascript
const a1 = [1, 2];
// 写法一
const a2 = [...a1];
// 写法二
const [...a2] = a1;
```

上面的两种写法，`a2`都是`a1`的克隆。

## 二、ES6之模版字符串

>  其实就是相当于c#的挖坑写法 只是语法不一样了
>
> ```
> consol.readline("你好，我是{0},我今年{1}岁了",nsme,age);  //c#写法
> 
> alert(`你好，我是${name},我今年${age}岁了`); //js写法 
> ```
>
> 　　最近在项目中使用了ES6的模版字符串，在这里加以总结。



1.之前我们也可以使用JavaScript输出模版字符串，通常是下面这样的：

```
        $("#result").append(
        "He is <b>"+person.name+"</b>"+"and we wish to know his"+person.age+".That is all" 
        );
```

　　但是我们可以看到：这样的传统做法需要使用大量的“”（双引号）和 + 来拼接才能得到我们需要的模版。但是这样是十分不方便的。

　于是ES6中提供了模版字符串**，用`（反引号）标识，用${}将变量括起来**。上面的例子可以用模版字符串写成下面这样：

```
        $("#result").append(
        `He is <b>${person.name}</b>and we wish to know his${person.age}.that is all`
        );
```

　　这样的做法就简洁了很多，我们不需要再使用大量的""和+来拼接字符串和变量。



　2.　当然，模版字符串可以引入变量，不使用变量也是可以的。如下所示：

```
` I am a man.`
 
 
` No matter what you do,
  I trust you.`
```

　　

　 3.　我们还可以先定义变量，然后在模版字符串中嵌入变量：

```
var name="zzw";
` ${name},no matter what you do,
  I trust you.`
```



　4.显然，由于反引号是模版字符串的标识，如果我们需要在字符串中使用反引号，我们就需要对其进行转义，如下所示：

```
    `No matter\` what you do,
      I trust you.` 
```

 

　 5.**注意：如果使用模版字符串表示多行字符串，所有的空格和缩进都会被保存在输出中！！**

```
console.log( `No matter\` what you do,
 I trust you.`);
```

　　输出结果如下：![img](img\1044137-20161204192458302-1057781587.png)

 

　6. 在${}中的大括号里**可以放入任意的JavaScript表达式，还可以进行运算**，以及引用对象属性。

```
    var x=88;
    var y=100;
    console.log(`x=${++x},y=${x+y}`);
```

结果如下所示：

![img](img\1044137-20161204193120693-1640821765.png)

 

　　7.更强大的是：模版字符串**还可以调用函数**：

```
function string(){
    return "zzw likes es6!";
}
console.log(`你想说什么?
            嗯，${string()}`);
```

　　结果如下所示：

![img](img\1044137-20161204193423677-1378015357.png)

 

　　另外，如果函数的结果不是字符串，那么，将按照一般的规则转化为字符串：

```
    function string(){
        return 666;
    }
    console.log(`你想说什么? 
                嗯，${string()}`);
```

　　结果如下所示：

![img](img\1044137-20161204193651490-2132392693.png)

　　在这里，实际上数字666被转化成了字符串666.

 

　　8.如果在${}中的变量时没有命名的，那么会报错：

```
    console.log(`你想说什么? 嗯，${string()}`);
```

　　在上面这句代码中，string()函数没有声明，于是报错：

![img](img\1044137-20161204193934990-247071044.png)

 

　　9.其实，我们还可以在${}中输入一个字符串，知识结果仍旧会返回一个字符串：

```
    console.log(`你想说什么?
             嗯，${"其实我不是变量~"}`);
```

　　结果如下所示：

 ![img](img\1044137-20161204194112631-1447459853.png)

　　

　　10.如果希望引用模版字符串本身，可以像下面这样写：　　

```
    let str="return"+"`Hello! ${name}`";
    let func=new Function("name",str);
    console.log(func("zzw"));
```

 结果如下：

​    ![img](img\1044137-20161204194550771-1769450591.png)

## 三、ES6新增字符串方法

#### 1.includes()、startsWith()、endsWith()

传统上，JavaScript 只有`indexOf`方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。

- **includes()**：返回布尔值，表示是否找到了参数字符串。
- **startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。
- **endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。

```javascript
let s = 'Hello world!';

s.startsWith('Hello') // true
s.endsWith('!') // true
s.includes('o') // true
```

这三个方法都支持第二个参数，表示开始搜索的位置。

```javascript
let s = 'Hello world!';

s.startsWith('world', 6) // true
s.endsWith('Hello', 5) // true
s.includes('Hello', 6) // false
```

上面代码表示，使用第二个参数`n`时，`endsWith`的行为与其他两个方法有所不同。它针对前`n`个字符，而其他两个方法针对从第`n`个位置直到字符串结束。

#### 2.replaceAll()

历史上，字符串的实例方法`replace()`只能替换第一个匹配。

```javascript
'aabbcc'.replace('b', '_')
// 'aa_bcc'
```

上面例子中，`replace()`只将第一个`b`替换成了下划线。

如果要替换所有的匹配，不得不使用正则表达式的`g`修饰符。

```javascript
'aabbcc'.replace(/b/g, '_')
// 'aa__cc'
```

正则表达式毕竟不是那么方便和直观，[ES2021](https://github.com/tc39/proposal-string-replaceall) 引入了`replaceAll()`方法，可以一次性替换所有匹配。

```javascript
'aabbcc'.replaceAll('b', '_')
// 'aa__cc'
```

它的用法与`replace()`相同，返回一个新字符串，不会改变原字符串。

```javascript
String.prototype.replaceAll(searchValue, replacement)
```

上面代码中，`searchValue`是搜索模式，可以是一个字符串，也可以是一个全局的正则表达式（带有`g`修饰符）。

如果`searchValue`是一个不带有`g`修饰符的正则表达式，`replaceAll()`会报错。这一点跟`replace()`不同。

```javascript
// 不报错
'aabbcc'.replace(/b/, '_')

// 报错
'aabbcc'.replaceAll(/b/, '_')
```

上面例子中，`/b/`不带有`g`修饰符，会导致`replaceAll()`报错。

`replaceAll()`的第二个参数`replacement`是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。

- `$&`：匹配的字符串。
- `$` `：匹配结果前面的文本。
- `$'`：匹配结果后面的文本。
- `$n`：匹配成功的第`n`组内容，`n`是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。
- `$$`：指代美元符号`$`。

下面是一些例子。

```javascript
// $& 表示匹配的字符串，即`b`本身
// 所以返回结果与原字符串一致
'abbc'.replaceAll('b', '$&')
// 'abbc'

// $` 表示匹配结果之前的字符串
// 对于第一个`b`，$` 指代`a`
// 对于第二个`b`，$` 指代`ab`
'abbc'.replaceAll('b', '$`')
// 'aaabc'

// $' 表示匹配结果之后的字符串
// 对于第一个`b`，$' 指代`bc`
// 对于第二个`b`，$' 指代`c`
'abbc'.replaceAll('b', `$'`)
// 'abccc'

// $1 表示正则表达式的第一个组匹配，指代`ab`
// $2 表示正则表达式的第二个组匹配，指代`bc`
'abbc'.replaceAll(/(ab)(bc)/g, '$2$1')
// 'bcab'

// $$ 指代 $
'abc'.replaceAll('b', '$$')
// 'a$c'
```

## 四、ES6之Array.form（）函数

`Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。

下面是一个类似数组的对象，`Array.from`将它转为真正的数组。

```javascript
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```

实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的`arguments`对象。`Array.from`都可以将它们转为真正的数组。

```javascript
// NodeList对象
let ps = document.querySelectorAll('p');
Array.from(ps).filter(p => {
  return p.textContent.length > 100;
});

// arguments对象
function foo() {
  var args = Array.from(arguments);
  // ...
}
```

只要是部署了 Iterator 接口的数据结构，`Array.from`都能将其转为数组。

```javascript
Array.from('hello')
// ['h', 'e', 'l', 'l', 'o']

let namesSet = new Set(['a', 'b'])
Array.from(namesSet) // ['a', 'b']
```

上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被`Array.from`转为真正的数组。

如果参数是一个真正的数组，`Array.from`会返回一个一模一样的新数组。

```javascript
Array.from([1, 2, 3])
// [1, 2, 3]
```

值得提醒的是，扩展运算符（`...`）也可以将某些数据结构转为数组。

扩展运算符背后调用的是遍历器接口（`Symbol.iterator`），如果一个对象没有部署这个接口，就无法转换。`Array.from`方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有`length`属性。因此，任何有`length`属性的对象，都可以通过`Array.from`方法转为数组，而此时扩展运算符就无法转换。

```javascript
Array.from({ length: 3 });
// [ undefined, undefined, undefined ]
```

上面代码中，`Array.from`返回了一个具有三个成员的数组，每个位置的值都是`undefined`。扩展运算符转换不了这个对象。

## 五、ES6之Array.of()

`Array.of()`方法用于将一组值，转换为数组。

```javascript
Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
```

`Array.of()`基本上可以用来替代`Array()`或`new Array()`，并且不存在由于参数不同而导致的重载。它的行为非常统一。

```javascript
Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
```

`Array.of()`总是返回参数值组成的数组。如果没有参数，就返回一个空数组。

# 2021.10.25

## 一、Array数组对象api汇总

| 函数名                                                       | 参数                                                         | 作用                                                         | 返回值                                     | 案例                                                         | 是否改变原数组 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | :----------------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------ | -------------- |
| Array.isArray()                                              | array实例                                                    | 判断参数是否为数组,可以弥补`typeof`运算符的不足。            | true/false                                 | <img src="img\image-20211025110641826.png" alt="image-20211025110641826" style="zoom:200%;" /> | 否             |
| arr.valueOf()                                                | 无                                                           | `valueOf`方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的`valueOf`方法不尽一致。数组的`valueOf`方法返回数组本身。 | 数组                                       | <img src="C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025110849175.png" alt="image-20211025110849175" style="zoom:200%;" /> | 否             |
| arr.toString()                                               | 无                                                           | `toString`方法也是对象的通用方法，数组的`toString`方法返回数组的字符串形式。 | 字符串                                     | <img src="C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025112547953.png" alt="image-20211025112547953" style="zoom:200%;" /> | 否             |
| arr.push()                                                   | 必需。要添加到数组中的项目。                                 | `push`方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。 | 数字（新数组长度）                         | ![image-20211025113214285](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025113214285.png) | 是             |
| arr.pop()                                                    | 无                                                           | `pop`方法用于删除数组的最后一个元素，并返回该元素。          | 数组元素                                   | ![image-20211025113318678](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025113318678.png)对空数组使用`pop`方法，不会报错，而是返回`undefined`。![image-20211025113356316](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025113356316.png) | 是             |
| arr.shift()                                                  | 无                                                           | `shift`方法用于删除数组的第一个元素，并返回该元素。          | 数组元素                                   | ![image-20211025135833109](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025135833109.png)`shift`方法可以遍历并清空一个数组。![image-20211025135746052](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025135746052.png) | 是             |
| arr.unshift()                                                | 必需。要添加到数组开头的项。                                 | `unshift`方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。 | 数字（添加新元素后数组的长度）             | ![image-20211025141325087](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025141325087.png)`unshift`方法可以接受多个参数，这些参数都会添加到目标数组头部。![image-20211025141344057](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025141344057.png) | 是             |
| arr.join()                                                   | 可选。要使用的分隔符。如果省略，元素用逗号分隔。             | `join`方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。 | 字符串值，表示数组值，由指定的分隔符分隔。 | ![image-20211025141654449](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025141654449.png)如果数组成员是`undefined`或`null`或空位，会被转成空字符串。![image-20211025141744324](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025141744324.png) | 否             |
| arr.concat()                                                 | 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。 | `concat`方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组 | 新数组                                     | ![image-20211025143711000](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025143711000.png)如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。<img src="C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025150251278.png" alt="image-20211025150251278" style="zoom: 200%;" /> | 否             |
| arr.reverse()                                                | 无                                                           | `reverse`方法用于颠倒排列数组元素，返回改变后的数组。        | 改变后的数组                               | ![image-20211025144027282](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025144027282.png) | 是             |
| arr.slice(start, end)                                        | **start**:可选，规定从何处开始选取。如果是负数，则表示从原数组中的倒数第几个元素开始提取。slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。 | `slice`方法用于提取目标数组的一部分，返回一个新数组。        | 新数组                                     | ![image-20211025150040495](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025150040495.png) | 否             |
|                                                              | **end**:可选，为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。 |                                                              |                                            | ![image-20211025150535777](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025150535777.png)上面代码中，最后一个例子`slice`没有参数，实际上等于返回一个原数组的拷贝。![image-20211025150627301](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025150627301.png)如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组。 |                |
| arr.splice(start,        count, addElement1, addElement2, ...) | **start**：必需。规定从何处添加/删除元素，是数字（从0开始）。 **count**：可选。规定应该删除多少元素。必须是数字，但可以是 "0"。 如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。**addElement...**:可选。要添加到数组的新元素 | `splice`方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员。 | 返回被删除的元素组成的数组。               | ![image-20211025152638902](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025152638902.png)上面代码从原数组4号位置，删除了两个数组成员。![image-20211025152735951](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025152735951.png)上面代码除了删除成员，还插入了两个新成员。![image-20211025153131208](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025153131208.png)起始位置如果是负数，就表示从倒数位置开始删除。上面代码表示，从倒数第四个位置`c`开始删除两个成员。![image-20211025153203923](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025153203923.png)如果只是单纯地插入元素，`splice`方法的第二个参数可以设为`0`。![image-20211025153231835](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025153231835.png)如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。 | 是             |
| arr.sort()                                                   | ***sortfunction***：可选。规定排序顺序。必须是函数。`sort`方法对数组成员进行排序，默认是按照字典顺序排序。 | `sort`方法对数组成员进行排序，默认是按照字典顺序排序。       | 返回排序后的数组                           | ![image-20211025153632057](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025153632057.png)上面代码的最后两个例子，需要特殊注意。`sort`方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以`101`排在`11`的前面。![image-20211025154002947](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025154002947.png)如果想让`sort`方法按照自定义方式排序，可以传入一个函数作为参数。上面代码中，`sort`的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于`0`，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。<img src="C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025154836064.png" alt="image-20211025154836064" style="zoom:67%;" /> | 是             |
| arr.map()                                                    | `map`方法接受一个函数作为参数。该函数调用时，`map`方法向它传入三个参数：当前成员、当前位置和数组本身。 | `map`方法将数组的所有成员依次传入参数函数，然后把**每一次的执行结果**组成一个新数组返回。 | 新数组                                     | ![image-20211025160546836](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025160546836.png)如果数组有空位，`map`方法的回调函数在这个位置不会执行，会跳过数组的空位。![image-20211025160938358](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025160938358.png) | 否             |
| arr.forEach()                                                | 参数是函数，函数有三个参数：当前值(必需）、当前位置（可选）、整个数组（可选）。 | `forEach`方法与`map`方法很相似，也是对数组的所有成员依次执行参数函数。但是，`forEach`方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用`map`方法，否则使用`forEach`方法。注意，`forEach`方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用`for`循环。`forEach`方法也会跳过数组的空位。 | 无                                         | ![image-20211025161508681](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025161508681.png)上面代码中，`forEach`遍历数组不是为了得到返回值，而是为了在屏幕输出内容，所以不必使用`map`方法。 | 否             |
| arr.filter()                                                 | 参数是函数，函数有三个参数：当前值(必需）、当前位置（可选）、整个数组（可选）。 | 它的参数是一个函数，所有数组成员依次执行该函数，返回结果为`true`的成员组成一个新数组返回。 | 新数组                                     | ![image-20211025162553136](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025162553136.png)上面代码返回偶数位置的成员组成的新数组。 | 否             |
| arr.some()                                                   | 参数是函数，函数有三个参数：当前值(必需）、当前位置（可选）、整个数组（可选）。 | `some`方法是只要一个成员的返回值是`true`，则整个`some`方法的返回值就是`true`，否则返回`false`。 | true/false                                 | ![image-20211025162840119](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025162840119.png)上面代码中，如果数组`arr`有一个成员大于等于3，`some`方法就返回`true`。 | 否             |
| arr.every()                                                  | 参数是函数，函数有三个参数：当前值(必需）、当前位置（可选）、整个数组（可选）。 | `every`方法是所有成员的返回值都是`true`，整个`every`方法才返回`true`，否则返回`false`。 | true/false                                 | ![image-20211025162910103](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025162910103.png)上面代码中，数组`arr`并非所有成员大于等于`3`，所以返回`false`。 | 否             |
| arr.reduce(*function (total, currentValue, index,arr)*)      | **total**:必需。*初始值*, 或者计算结束后的返回值。**currentValue**:必需。当前元素。***currentIndex***：可选。当前元素的索引。***arr***：可选。当前元素所属的数组对象。 | 依次处理数组的每个成员，最终累计为一个值。                   | 返回计算结果                               | ![image-20211025212842347](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025212842347.png) | 否             |
| arr.indexOf(*item*,*start*)                                  | 第一个参数数组项，第二个参数，表示搜索的开始位置（非必须）。 | `indexOf`方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回`-1`。 | 数字（位置或-1）                           | ![image-20211025220232810](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025220232810.png) | 否             |
| arr.lastIndexOf (*item*,*start*)                             | 第一个参数数组项，第二个参数，表示搜索的开始位置（非必须），如省略该参数，则将从字符串的最后一个字符处开始检索。。 | `indexOf`方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回`-1`。 | 数字（位置或-1）                           | ![image-20211025221933894](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025221933894.png)![image-20211025221949643](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211025221949643.png)注意，这两个方法不能用来搜索`NaN`的位置，即它们无法确定数组成员是否包含`NaN`。 | 否             |
| Array.from（）                                               | *object*：必需，要转换为数组的对象。                         | `Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。只要是部署了 Iterator 接口的数据结构，`Array.from`都能将其转为数组。 | 数组                                       | <img src="img\image-20211101175518252.png" alt="image-20211101175518252" style="zoom:200%;" /> | 否             |
| Array.of()                                                   | 值                                                           | `Array.of()`方法用于将一组值，转换为数组。                   | 数组                                       | ![image-20211101181238233](img\image-20211101181238233.png)  | 否             |
| arr.find()                                                   | 回调函数function(value, index, arr) { }                      | 数组实例的`find`方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员。如果没有符合条件的成员，则返回`undefined`。 | 数组项                                     | ![image-20211122161551716](img\image-20211122161551716.png)  | 否             |
| arr.findIndex()                                              | 回调函数function(value, index, arr) { }                      | 数组实例的`findIndex`方法的用法与`find`方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1`。 | 索引值                                     | ![image-20211122161751612](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211122161751612.png) | 否             |
| arr.fill()                                                   | value,startInd,endInd值，起始位置，结束位置                  | `fill`方法使用给定值，填充一个数组。                         | 数组                                       | ![image-20211122163449293](img\image-20211122163449293.png)上面代码表明，`fill`方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 `fill`方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。![image-20211122163716431](img\image-20211122163716431.png)上面代码表示，`fill`方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。                           注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。![image-20211122165056703](img\image-20211122165056703.png) | 是             |
| `entries()`，`keys()`和`values()`                            | 无                                                           | ES6 提供三个新的方法——`entries()`，`keys()`和`values()`——用于遍历数组。它们都返回一个遍历器对象，可以用`for...of`循环进行遍历，唯一的区别是`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。 | 遍历器对象                                 | ![image-20211122165807897](img\image-20211122165807897.png)  | 否             |
| arr.includes()                                               | 第一个参数值，该方法的第二个参数表示搜索的起始位置，默认为`0`。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为`-4`，但数组长度为`3`），则会重置为从`0`开始。 | 判断某个数组是否包含给定的值，与字符串的`includes`方法类似。 | 布尔值                                     | ![image-20211122171140946](C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211122171140946.png)![image-20211122170202923](img\image-20211122170202923.png)![image-20211122171516843](img\image-20211122171516843.png) | 否             |
| arr.flat（）                                                 | `flat()`默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将`flat()`方法的参数写成一个整数，表示想要拉平的层数，默认为1。 | 数组的成员有时还是数组，`Array.prototype.flat()`用于将嵌套的数组“拉平”，变成一维的数组。 | 新数组                                     | ![image-20211122171653263](img\image-20211122171653263.png)如果不管有多少层嵌套，都要转成一维数组，可以用`Infinity`关键字作为参数。 | 否             |
| arr.at()                                                     | 数值（表示位置）                                             | js以前不支持数组的负索引，如果要引用数组的最后一个成员，不能写成`arr[-1]`，只能使用`arr[arr.length - 1]`。为了解决这个问题为数组实例增加了`at()`方法，接受一个整数作为参数，返回对应位置的成员，支持负索引。这个方法不仅可用于数组，也可用于字符串和类型数组（TypedArray）。 | 数组项                                     | ![image-20211122174245096](img\image-20211122174245096.png)如果参数位置超出了数组范围，`at()`返回`undefined`。 | 否             |



# 2021.10.29

## 一、新建一个文件夹与远程仓库关联起来上传代码到某一分支

在某一文件夹下初始化git仓库

![image-20211029150407169](img\image-20211029150407169.png)

多了一个项目文件

![image-20211029150431607](img\image-20211029150431607.png)

默认是master分支上的代码

![image-20211029150449843](img\image-20211029150449843.png)

查看分支切换分支

![image-20211029151400860](img\image-20211029151400860.png)

文件变成Dev分支下的代码

<img src="img\image-20211029151429214.png" alt="image-20211029151429214" style="zoom: 50%;" />

# 2021.11.1

## 一、vscode使用技巧

### 1. 定义一键生成代码框架的模板

在使用VSCode作为非生产力工具时，每个vue文件，都要写一遍template/div/script/style，比较麻烦。

今天来介绍一下模板，可以一键生成咱们设置好的模板。（本文以vue文件为例，其余语言同理，修改构建文件即可）

#### a.选择菜单里的 文件 > 首选项 > 用户代码片段

<img src="img\image-20211101172825032.png" alt="image-20211101172825032" style="zoom: 50%;" />

#### b.选择你需要自定义模板的文件，以vue为例

<img src="img\image-20211101173618823.png" alt="image-20211101173618823" style="zoom:67%;" />

#### c. 配置对应文件json

把代码片段写在json里。每个代码段都是在一个代码片段名称下定义的，并且有prefix、body和description。prefix是用来触发代码片段的。使用 $1，$2 等指定光标位置，这些数字指定了光标跳转的顺序，$0表示最终光标位置。

注意：**新文件中可能会有解释代码，是用来生成空的文档的，需要将他们全部注释，包括括号（统统注释）**

在`vue.json`的大括号中，书写如下代码：

```json
{
	// Place your snippets for vue here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"生成vue模板": {
		"prefix": "vue", //在新建立的页面中输入vue就会有智能提示，enter选择就好了
		"body": [
		"<template>"
		"	<div>"
		"   $0",//最终光标会在这里等待输入
		"	</div>"
		"</template>"
		"<script>"
	  	"export default {"
	  	"	name: '',"
	  	"	components: {},"
	  	"	data () {},"
	  	"	computed () {},"
	  	"	watch () {},"
	  	"	created () {},"
	  	"	methods: {}"
	  	"}"
		"</script>"
		"<style lang='scss' scoped>"
		""
		"</style>"
		""//空行也加进去
		],
		"description": "vue template" //用户输入后智能提示的内容（你可以用中文写“生成vue模板”）
	}
}
```

#### d.在`.vue`文件中使用模板

<img src="img\image-20211101174050394.png" alt="image-20211101174050394" style="zoom:50%;" />

<img src="img\image-20211101174203984.png" alt="image-20211101174203984" style="zoom:50%;" />



## 二、vscode 打开新文件覆盖旧文件解决办法

[vscode](https://so.csdn.net/so/search?q=vscode&spm=1001.2101.3001.7020) 中默认开启了preview，此时临时单击打开的文件在打开新文件时会被覆盖，若需要保留新打开的文件，则可双击文件（在资源管理器栏或者文件标题）或者修改文件，文件就不会被覆盖。

若要关闭此功能，则可在左下角单击设置，settings-> [Workbench](https://so.csdn.net/so/search?q=Workbench&spm=1001.2101.3001.7020)->Editor Management 里去掉Enable Preview 的勾选项，此时单击的文件都会被保留。

# 2021.11.18

## 一、JS判断值是否是数字

## 1.使用isNaN()函数

**isNaN()的缺点就在于 null、空格以及空串会被按照0来处理**

NaN: Not a Number

```js
/**
 *判断是否是数字
 *
 **/

function isRealNum (val) {
  // isNaN()函数 把空串 空格 以及NUll 按照0来处理 所以先去除，
  if (val == null || val.trim().length === 0) {
    return false
  }
  if (!isNaN(val)) {
    // 对于空数组和只有一个数值成员的数组或全是数字组成的字符串，isNaN返回false，例如：'123'、[]、[2]、['123'],isNaN返回false,
    // 所以如果不需要val包含这些特殊情况，则这个判断改写为if(!isNaN(val) && typeof val === 'number' )
    return true
  } else {
    return false
  }
}
```

```
isNaN(123) //false
isNaN(-1.23) //false
isNaN(5-2) //false
isNaN(0) //false
isNaN('123') //false
isNaN('Hello') //true
isNaN('2005/12/12') //true
isNaN('') //false
isNaN(true) //false
isNaN(undefined) //true
isNaN('NaN') //true
isNaN(NaN) //true
isNaN(0 / 0) //true
isNaN(null) //false
```

此函数不同于 Number 特定的` Number.isNaN() `方法。

全局` isNaN()` 函数将测试值转换为数字，然后对其进行测试。

`Number.isNaN()` 不会将值转换为数字，并且不会为任何非数字类型的值返回 true。

## 二、Number（）的用法

Number() 函数将对象参数转换为表示对象值的数字。

如果该值无法转换为合法数字，则返回 NaN。

注释：如果参数是 Date 对象，则 Number() 函数返回自 UTC 1970 年 1 月 1 日午夜以来的毫秒数。

```
true 
false;
new Date();
"999";
"999 888";
```

# 2021.11.23

## 一、vue中使用lodash节流函数

```vue
<template>
  <div class="page">
        <van-search v-model="keyword" placeholder="请输入股票代码"
                    @blur="throttleQueryList" 
                    @search="throttleQueryList" />
  </div>
</template>
<script>
export default {
  data() {
    return {
      throttle: 500,
      throttleQueryList: () => {}
    };
  },
  computed: {
  },
  created() {
    this.throttleQueryList = throttle(() => {
      this.queryList()
    }, this.throttle)
  },
  mounted() {
    this.queryList();
  },
  methods: {
    queryList() {
      const data = {
        stock_code: this.keyword || '',
        position_str: 0,
        request_num: 100
      }
      this.$services
      .finexeAssureCodeQuery({
        method: 'post',
        data
      })
      .then((res) => {
        this.pageData.data = res.data;
      })
      .catch((e) => {
        console.log(e);
        this.$toast(e.error_info);
      });
    },
  },
};
</script>
```

# 2021.11.25

# 一、cookie、session、token、jwt

[参考博客](https://juejin.cn/post/6844904034181070861)

# 2021.12.2

## 一、git 回滚到之前某一commit

1. `git log `

    查看提交历史

2. `git reset --hard  <commit id>`

3.  `git push origin HEAD --force`

​         强推到远程

# 2021.12.9

## 一、js对象的遍历

1. **for in**

```js
Object.prototype.fun = () => {};
const obj = { 2: 'a', 1: 'b' };
for (let i in obj) {
  console.log(i, ':', obj[i]);
}
// 1: b
// 2: a
// fun : () => {} Object 原型链上扩展的方法也被遍历出来
```

```js
for (let i in obj) {
  if (Object.prototype.hasOwnProperty.call(obj, i)) {
      console.log(i, ':', obj[i]);
    }
}
// 1: b
// 2: a
```

使用 for in 循环时，返回的是所有能够通过对象访问的、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中的实例。如果只需要获取对象的实例属性，可以使用 hasOwnProperty 进行过滤。

2. **Object.keys**

```js
Object.prototype.fun = () => {};

const str = 'abc';
console.log(Object.keys(str));
// ['0', '1', '2']

const arr = ['a', 'b','c','d'];
console.log(Object.keys(arr));
//  ['0', '1', '2', '3']

const obj = { 1: 'b', 2: 'a' };
console.log(Object.keys(obj));
// ['1', '2']
```

用于获取对象自身所有的**可枚举**的属性值，但不包括原型中的属性，然后返回一个由属性名组成的数组。

3. **Object.values**

```js
Object.prototype.fun = () => {};

const str = 'abcd';
console.log(Object.values(str));
// ['a', 'b', 'c', 'd']

const arr = ['a', 'b'];
console.log(Object.values(arr));
// ['a', 'b']

const obj = { 1: 'b', 0: 'a' ,2:'c'};
console.log(Object.values(obj));
// ['a', 'b', 'c']
```

用于获取对象自身所有的**可枚举**的属性值，但不包括原型中的属性，然后返回一个由属性值组成的数组。

4. **Object.entries**

```js
const str = 'ab';
for (const [key, value] of Object.entries(str)) {
    console.log(`${key}: ${value}`);
}
// 0: a
// 1: b
const arr = ['a', 'b'];
for (const [key, value] of Object.entries(arr)) {
    console.log(`${key}: ${value}`);
}
// 0: a
// 1: b
const obj = { 1: 'b', 0: 'a' };
for (const [key, value] of Object.entries(obj)) {
    console.log(`${key}: ${value}`);
}
// 0: a
// 1: b
```

```js
示例1 -- 传入对象
const obj = { foo: 'bar', baz: 'abc' }; 
console.log(Object.entries(obj));  // [['foo', 'bar'], ['baz', 'abc']]

示例2 -- 数组
const arr = [1, 2, 3]; 
console.log(Object.entries(arr));  // [['0', 1], ['1', '2'], ['2', '3']]

示例3 -- 数组（数组中包含对象）
const arr1 = [{ a: 1 }, 2, 3]; 
console.log(Object.entries(arr1));  // [['0', { a: 1 }], ['1', '2'], ['2', '3']]

示例4 -- 数组（数组中的值全部为对象）
const arr2 = [{ a: 1 }, { b: 2 }, { c: 3 }]; 
console.log(Object.entries(arr2));  // [['0', { a: 1 }], ['1', { b: 2 }], ['2', { c: 3 }]]

示例5 -- 字符串
const str = '123'; 
console.log(Object.entries(str));  // [['0', '1'], ['1', '2'], ['2', '3']]
```



`Object.entries()` 方法返回一个给定对象自身**可枚举**属性的键值对数组，其排列与使用 `for...in` 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。

通俗点就是 `Object.entries()` 可以把一个对象的键值以数组的形式遍历出来，结果和 `for...in` 一致，但不会遍历原型属性。

5. **Object.getOwnPropertyNames**

```js
const str = 'ab';
console.log(Object.getOwnPropertyNames(str));
// ['0', '1', 'length']

Array.prototype.fun = () => {};
const arr = ['a', 'b'];
console.log(Object.getOwnPropertyNames(arr));
// ['0', '1', 'length']

Object.prototype.fun = () => {};
const obj = { 1: 'b', 0: 'a' };
console.log(Object.getOwnPropertyNames(obj));
// ['0', '1']
```

用于获取对象自身所有的可枚举以及不可枚举的属性值，但不包括原型中的属性，然后返回一个由属性名组成的数组。

对于一般的对象来说，`Object.keys()`和`Object.getOwnPropertyNames()`返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。`Object.keys`方法只返回可枚举的属性，`Object.getOwnPropertyNames`方法还返回不可枚举的属性名。

数组的`length`属性是不可枚举的属性，所以只出现在`Object.getOwnPropertyNames`方法的返回结果中。

# 2021.12.16

## Vue——组件通信

vue是数据驱动视图更新的框架, 所以对于vue来说组件间的数据通信非常重要，那么组件之间如何进行数据通信的呢？ 首先我们需要知道在vue中组件之间存在什么样的关系, 才更容易理解他们的通信方式, 就好像过年回家，坐着一屋子的陌生人，相互之间怎么称呼，这时就需要先知道自己和他们之间是什么样的关系。 vue组件中关系说明:



![](img\1234.png.png)

如上图所示, A与B、A与C、B与D、C与E组件之间是父子关系； B与C之间是兄弟关系；A与D、A与E之间是隔代关系； D与E是堂兄关系（非直系亲属） 针对以上关系我们归类为：

- 父子组件之间通信
- 非父子组件之间通信(兄弟组件、隔代关系组件等)

本文会介绍组件间通信的8种方式如下图目录所示:并介绍在不同的场景下如何选择有效方式实现的组件间通信方式，希望可以帮助小伙伴们更好理解组件间的通信。

![](img\5657.png.png)

### 一、`props` / `$emit`

父组件通过`props`的方式向子组件传递数据，而通过`$emit` 子组件可以向父组件通信。

#### 1. 父组件向子组件传值

下面通过一个例子说明父组件如何向子组件传递数据：在子组件`article.vue`中如何获取父组件`section.vue`中的数据`articles:['红楼梦', '西游记','三国演义']`

```vue
// section父组件
<template>
  <div class="section">
    <com-article :articles="articleList"></com-article>
  </div>
</template>

<script>
import comArticle from './test/article.vue'
export default {
  name: 'HelloWorld',
  components: { comArticle },
  data() {
    return {
      articleList: ['红楼梦', '西游记', '三国演义']
    }
  }
}
</script>


```

```vue
// 子组件 article.vue
<template>
  <div>
    <span v-for="(item, index) in articles" :key="index">{{item}}</span>
  </div>
</template>

<script>
export default {
  props: ['articles']
}
</script>

```

> 总结: prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告。

#### 2. 子组件向父组件传值

对于`$emit` 我自己的理解是这样的: `$emit`绑定一个自定义事件, 当这个语句被执行时, 就会将参数arg传递给父组件,父组件通过v-on监听并接收参数。 通过一个例子，说明子组件如何向父组件传递数据。 在上个例子的基础上, 点击页面渲染出来的`ariticle`的`item`, 父组件中显示在数组中的下标

```vue
// 父组件中
<template>
  <div class="section">
    <com-article :articles="articleList" @onEmitIndex="onEmitIndex"></com-article>
    <p>{{currentIndex}}</p>
  </div>
</template>

<script>
import comArticle from './test/article.vue'
export default {
  name: 'HelloWorld',
  components: { comArticle },
  data() {
    return {
      currentIndex: -1,
      articleList: ['红楼梦', '西游记', '三国演义']
    }
  },
  methods: {
    onEmitIndex(idx) {
      this.currentIndex = idx
    }
  }
}
</script>

```

```vue
<template>
  <div>
    <div v-for="(item, index) in articles" :key="index" @click="emitIndex(index)">{{item}}</div>
  </div>
</template>

<script>
export default {
  props: ['articles'],
  methods: {
    emitIndex(index) {
      this.$emit('onEmitIndex', index)
    }
  }
}
</script>

```

##### a.Vue中子组件向父组件$emit传递一个和多个参数方法

###### 1. 一个参数

子组件向父组件传递一个参数时主要有以下两种方法

```
//子组件
this.$emit('itemClick',item)
```

**方法一：不加括号**

```vue
//父组件 
<div id="app">
   <Child @itemClick="handleItemClick"/>
 </div>
 
methods:{
    handleItemClick(item){
     console.log(item)
    }
  }
```

可以看到，如果父组件的事件处理函数不加括号，那么子组件传递过来的值将会作为第一个参数传入这个函数 。

**方法二：使用$event接收** 

```vue
//父组件 
<div id="app">
   <Child @itemClick="handleItemClick($event)"/>
 </div>
 
//以下不变
methods:{
    handleItemClick(item){
     console.log(item)
    }
  }
```

###### 2. 多个参数 

**子组件向父组件传递多个参数时，父组件接收时采用arguments 以数组的形式传入**

```vue
//子组件
this.$emit('itemClick',param1,param2)
```

```vue
//父组件 
<div id="app">
   <Child @itemClick="handleItemClick(arguments)"/>
</div>
 
  methods:{
    handleItemClick(params){
      console.log(params)
      console.log(params[0])
      console.log(params[1])
    }
  }
```

结果如下：

![img](img\20201012095600586.png)

### 二、 `$children` / `$parent`

![image-20211216100609846](img\image-20211216100609846.png)

![image-20211216101150682](img\image-20211216101150682.png)

上面这张图片是`vue`官方的解释，通过`$parent`和`$children`就可以访问组件的实例，拿到实例代表什么？代表可以访问此组件的所有方法和`data`。接下来就是怎么实现拿到指定组件的实例。

```vue
// 父组件中
<template>
  <div class="hello_world">
    <div>{{msg}}</div>
    <com-a></com-a>
    <button @click="changeA">点击改变子组件值</button>
  </div>
</template>

<script>
import ComA from './test/comA.vue'
export default {
  name: 'HelloWorld',
  components: { ComA },
  data() {
    return {
      msg: 'Welcome'
    }
  },

  methods: {
    changeA() {
      // 获取到子组件A
      this.$children[0].messageA = 'this is new value'
    }
  }
}
</script>

```

```vue
// 子组件中
<template>
  <div class="com_a">
    <span>{{messageA}}</span>
    <p>获取父组件的值为:  {{parentVal}}</p>
  </div>
</template>

<script>
export default {
  data() {
    return {
      messageA: 'this is old'
    }
  },
  computed:{
    parentVal(){
      return this.$parent.msg;
    }
  }
}
</script>

```

> 要注意边界情况，如在`#app`上拿`$parent`得到的是`new Vue()`的实例，在这实例上再拿`$parent`得到的是`undefined`，而在最底层的子组件拿`$children`是个空数组。也要注意得到`$parent`和`$children`的值不一样，`$children` 的值是数组(因为可能有多个子组件，所以可以通过[]下标来获取某一子组件)，而`$parent`是个对象

#### 总结

上面两种方式用于父子组件之间的通信， 而使用props进行父子组件通信更加普遍; 二者皆不能用于非父子组件之间的通信。

# 2021.12.17

# chrome开发工具详解——Network篇

> Network 面板记录页面上每个网络操作的相关信息，包括详细的耗时数据、HTTP 请求与响应标头和 Cookie，等等。

## 一、Network面板概览

<img src="C:\Users\wangrj32319\AppData\Roaming\Typora\typora-user-images\image-20211229201547667.png" alt="image-20211229201547667" style="zoom: 67%;" />



# 2021.12.20

## min-width的使用

![image-20211220133507958](img\image-20211220133507958.png)

![image-20211220133540795](img\image-20211220133540795.png)

![image-20211220133607598](img\image-20211220133607598.png)

# 2021.12.23

## git还原某个特定的文件到之前的版本

场景： 对于某个[Git](http://lib.csdn.net/base/git)控制下的文件进行了修改，但是改的不满意，想退回到改之前的版本。假定该文件为 src/main/main.c

解决方法：

第一步： 在命令行中输入 [git](http://lib.csdn.net/base/git) log src/main/main.c 得到该文件的commit 历史。 会得到类似下面的界面

 

第二步： 复制需要回退版本的hash，在此假设我们回退到 d98a0f565804ba639ba46d6e4295d4f787ff2949 ,则复制该序列即可

第三步：checkout 对应版本。格式为 git checkout <hash> <filename>, 在此即为命令行中输入 git checkout d98a0f565804ba639ba46d6e4295d4f787ff2949 src/main/main.c

第四步： commit checkout下来的版本。 如： git commit -m "revert to previous version"

 

 

注意： 第三步中不要忘记加 文件属性，即src/main/main.c

# 2021.12.28

## vscode git扩展程序
